diff -Napur linux-linux4microchip-2022.10-orig/drivers/dma/at_hdmac.c linux-linux4microchip-2022.10/drivers/dma/at_hdmac.c
--- linux-linux4microchip-2022.10-orig/drivers/dma/at_hdmac.c	2022-11-09 04:48:42.000000000 -0800
+++ linux-linux4microchip-2022.10/drivers/dma/at_hdmac.c	2023-04-26 12:59:50.774635157 -0700
@@ -3,7 +3,6 @@
  * Driver for the Atmel AHB DMA Controller (aka HDMA or DMAC on AT91 systems)
  *
  * Copyright (C) 2008 Atmel Corporation
- * Copyright (C) 2022 Microchip Technology, Inc. and its subsidiaries
  *
  * This supports the Atmel AHB DMA Controller found in several Atmel SoCs.
  * The only Atmel DMA Controller that is not covered by this driver is the one
@@ -11,22 +10,20 @@
  */
 
 #include <dt-bindings/dma/at91.h>
-#include <linux/bitfield.h>
 #include <linux/clk.h>
 #include <linux/dmaengine.h>
-#include <linux/dmapool.h>
 #include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
 #include <linux/of.h>
-#include <linux/overflow.h>
 #include <linux/of_device.h>
 #include <linux/of_dma.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
 
+#include "at_hdmac_regs.h"
 #include "dmaengine.h"
-#include "virt-dma.h"
 
 /*
  * Glossary
@@ -37,440 +34,9 @@
  * atc_	/ atchan	: ATmel DMA Channel entity related
  */
 
-#define	AT_DMA_MAX_NR_CHANNELS	8
-
-/* Global Configuration Register */
-#define AT_DMA_GCFG		0x00
-#define AT_DMA_IF_BIGEND(i)	BIT((i))	/* AHB-Lite Interface i in Big-endian mode */
-#define AT_DMA_ARB_CFG		BIT(4)		/* Arbiter mode. */
-
-/* Controller Enable Register */
-#define AT_DMA_EN		0x04
-#define AT_DMA_ENABLE		BIT(0)
-
-/* Software Single Request Register */
-#define AT_DMA_SREQ		0x08
-#define AT_DMA_SSREQ(x)		BIT((x) << 1)		/* Request a source single transfer on channel x */
-#define AT_DMA_DSREQ(x)		BIT(1 + ((x) << 1))	/* Request a destination single transfer on channel x */
-
-/* Software Chunk Transfer Request Register */
-#define AT_DMA_CREQ		0x0c
-#define AT_DMA_SCREQ(x)		BIT((x) << 1)		/* Request a source chunk transfer on channel x */
-#define AT_DMA_DCREQ(x)		BIT(1 + ((x) << 1))	/* Request a destination chunk transfer on channel x */
-
-/* Software Last Transfer Flag Register */
-#define AT_DMA_LAST		0x10
-#define AT_DMA_SLAST(x)		BIT((x) << 1)		/* This src rq is last tx of buffer on channel x */
-#define AT_DMA_DLAST(x)		BIT(1 + ((x) << 1))	/* This dst rq is last tx of buffer on channel x */
-
-/* Request Synchronization Register */
-#define AT_DMA_SYNC		0x14
-#define AT_DMA_SYR(h)		BIT((h))		/* Synchronize handshake line h */
-
-/* Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt registers */
-#define AT_DMA_EBCIER		0x18			/* Enable register */
-#define AT_DMA_EBCIDR		0x1c			/* Disable register */
-#define AT_DMA_EBCIMR		0x20			/* Mask Register */
-#define AT_DMA_EBCISR		0x24			/* Status Register */
-#define AT_DMA_CBTC_OFFSET	8
-#define AT_DMA_ERR_OFFSET	16
-#define AT_DMA_BTC(x)		BIT((x))
-#define AT_DMA_CBTC(x)		BIT(AT_DMA_CBTC_OFFSET + (x))
-#define AT_DMA_ERR(x)		BIT(AT_DMA_ERR_OFFSET + (x))
-
-/* Channel Handler Enable Register */
-#define AT_DMA_CHER		0x28
-#define AT_DMA_ENA(x)		BIT((x))
-#define AT_DMA_SUSP(x)		BIT(8 + (x))
-#define AT_DMA_KEEP(x)		BIT(24 + (x))
-
-/* Channel Handler Disable Register */
-#define AT_DMA_CHDR		0x2c
-#define AT_DMA_DIS(x)		BIT(x)
-#define AT_DMA_RES(x)		BIT(8 + (x))
-
-/* Channel Handler Status Register */
-#define AT_DMA_CHSR		0x30
-#define AT_DMA_EMPT(x)		BIT(16 + (x))
-#define AT_DMA_STAL(x)		BIT(24 + (x))
-
-/* Channel registers base address */
-#define AT_DMA_CH_REGS_BASE	0x3c
-#define ch_regs(x)		(AT_DMA_CH_REGS_BASE + (x) * 0x28) /* Channel x base addr */
-
-/* Hardware register offset for each channel */
-#define ATC_SADDR_OFFSET	0x00	/* Source Address Register */
-#define ATC_DADDR_OFFSET	0x04	/* Destination Address Register */
-#define ATC_DSCR_OFFSET		0x08	/* Descriptor Address Register */
-#define ATC_CTRLA_OFFSET	0x0c	/* Control A Register */
-#define ATC_CTRLB_OFFSET	0x10	/* Control B Register */
-#define ATC_CFG_OFFSET		0x14	/* Configuration Register */
-#define ATC_SPIP_OFFSET		0x18	/* Src PIP Configuration Register */
-#define ATC_DPIP_OFFSET		0x1c	/* Dst PIP Configuration Register */
-
-/* Bitfield definitions */
-/* Bitfields in DSCR */
-#define ATC_DSCR_IF		GENMASK(1, 0)	/* Dsc feched via AHB-Lite Interface */
-
-/* Bitfields in CTRLA */
-#define ATC_BTSIZE_MAX		GENMASK(15, 0)	/* Maximum Buffer Transfer Size */
-#define ATC_BTSIZE		GENMASK(15, 0)	/* Buffer Transfer Size */
-#define ATC_SCSIZE		GENMASK(18, 16)	/* Source Chunk Transfer Size */
-#define ATC_DCSIZE		GENMASK(22, 20)	/* Destination Chunk Transfer Size */
-#define ATC_SRC_WIDTH		GENMASK(25, 24)	/* Source Single Transfer Size */
-#define ATC_DST_WIDTH		GENMASK(29, 28)	/* Destination Single Transfer Size */
-#define ATC_DONE		BIT(31)	/* Tx Done (only written back in descriptor) */
-
-/* Bitfields in CTRLB */
-#define ATC_SIF			GENMASK(1, 0)	/* Src tx done via AHB-Lite Interface i */
-#define ATC_DIF			GENMASK(5, 4)	/* Dst tx done via AHB-Lite Interface i */
-#define AT_DMA_MEM_IF		0x0		/* interface 0 as memory interface */
-#define AT_DMA_PER_IF		0x1		/* interface 1 as peripheral interface */
-#define ATC_SRC_PIP		BIT(8)		/* Source Picture-in-Picture enabled */
-#define ATC_DST_PIP		BIT(12)		/* Destination Picture-in-Picture enabled */
-#define ATC_SRC_DSCR_DIS	BIT(16)		/* Src Descriptor fetch disable */
-#define ATC_DST_DSCR_DIS	BIT(20)		/* Dst Descriptor fetch disable */
-#define ATC_FC			GENMASK(22, 21)	/* Choose Flow Controller */
-#define ATC_FC_MEM2MEM		0x0		/* Mem-to-Mem (DMA) */
-#define ATC_FC_MEM2PER		0x1		/* Mem-to-Periph (DMA) */
-#define ATC_FC_PER2MEM		0x2		/* Periph-to-Mem (DMA) */
-#define ATC_FC_PER2PER		0x3		/* Periph-to-Periph (DMA) */
-#define ATC_FC_PER2MEM_PER	0x4		/* Periph-to-Mem (Peripheral) */
-#define ATC_FC_MEM2PER_PER	0x5		/* Mem-to-Periph (Peripheral) */
-#define ATC_FC_PER2PER_SRCPER	0x6		/* Periph-to-Periph (Src Peripheral) */
-#define ATC_FC_PER2PER_DSTPER	0x7		/* Periph-to-Periph (Dst Peripheral) */
-#define ATC_SRC_ADDR_MODE	GENMASK(25, 24)
-#define ATC_SRC_ADDR_MODE_INCR	0x0		/* Incrementing Mode */
-#define ATC_SRC_ADDR_MODE_DECR	0x1		/* Decrementing Mode */
-#define ATC_SRC_ADDR_MODE_FIXED	0x2		/* Fixed Mode */
-#define ATC_DST_ADDR_MODE	GENMASK(29, 28)
-#define ATC_DST_ADDR_MODE_INCR	0x0		/* Incrementing Mode */
-#define ATC_DST_ADDR_MODE_DECR	0x1		/* Decrementing Mode */
-#define ATC_DST_ADDR_MODE_FIXED	0x2		/* Fixed Mode */
-#define ATC_IEN			BIT(30)		/* BTC interrupt enable (active low) */
-#define ATC_AUTO		BIT(31)		/* Auto multiple buffer tx enable */
-
-/* Bitfields in CFG */
-#define ATC_PER_MSB(h)	((0x30U & (h)) >> 4)	/* Extract most significant bits of a handshaking identifier */
-
-#define ATC_SRC_PER		GENMASK(3, 0)	/* Channel src rq associated with periph handshaking ifc h */
-#define ATC_DST_PER		GENMASK(7, 4)	/* Channel dst rq associated with periph handshaking ifc h */
-#define ATC_SRC_REP		BIT(8)		/* Source Replay Mod */
-#define ATC_SRC_H2SEL		BIT(9)		/* Source Handshaking Mod */
-#define ATC_SRC_PER_MSB		GENMASK(11, 10)	/* Channel src rq (most significant bits) */
-#define ATC_DST_REP		BIT(12)		/* Destination Replay Mod */
-#define ATC_DST_H2SEL		BIT(13)		/* Destination Handshaking Mod */
-#define ATC_DST_PER_MSB		GENMASK(15, 14)	/* Channel dst rq (most significant bits) */
-#define ATC_SOD			BIT(16)		/* Stop On Done */
-#define ATC_LOCK_IF		BIT(20)		/* Interface Lock */
-#define ATC_LOCK_B		BIT(21)		/* AHB Bus Lock */
-#define ATC_LOCK_IF_L		BIT(22)		/* Master Interface Arbiter Lock */
-#define ATC_AHB_PROT		GENMASK(26, 24)	/* AHB Protection */
-#define ATC_FIFOCFG		GENMASK(29, 28)	/* FIFO Request Configuration */
-#define ATC_FIFOCFG_LARGESTBURST	0x0
-#define ATC_FIFOCFG_HALFFIFO		0x1
-#define ATC_FIFOCFG_ENOUGHSPACE		0x2
-
-/* Bitfields in SPIP */
-#define ATC_SPIP_HOLE		GENMASK(15, 0)
-#define ATC_SPIP_BOUNDARY	GENMASK(25, 16)
-
-/* Bitfields in DPIP */
-#define ATC_DPIP_HOLE		GENMASK(15, 0)
-#define ATC_DPIP_BOUNDARY	GENMASK(25, 16)
-
-#define ATC_SRC_PER_ID(id)	(FIELD_PREP(ATC_SRC_PER_MSB, (id)) |	\
-				 FIELD_PREP(ATC_SRC_PER, (id)))
-#define ATC_DST_PER_ID(id)	(FIELD_PREP(ATC_DST_PER_MSB, (id)) |	\
-				 FIELD_PREP(ATC_DST_PER, (id)))
-
-
-/*--  descriptors  -----------------------------------------------------*/
-
-/* LLI == Linked List Item; aka DMA buffer descriptor */
-struct at_lli {
-	/* values that are not changed by hardware */
-	u32 saddr;
-	u32 daddr;
-	/* value that may get written back: */
-	u32 ctrla;
-	/* more values that are not changed by hardware */
-	u32 ctrlb;
-	u32 dscr;	/* chain to next lli */
-};
-
-/**
- * struct atdma_sg - atdma scatter gather entry
- * @len: length of the current Linked List Item.
- * @lli: linked list item that is passed to the DMA controller
- * @lli_phys: physical address of the LLI.
- */
-struct atdma_sg {
-	unsigned int len;
-	struct at_lli *lli;
-	dma_addr_t lli_phys;
-};
-
-/**
- * struct at_desc - software descriptor
- * @vd: pointer to the virtual dma descriptor.
- * @atchan: pointer to the atmel dma channel.
- * @total_len: total transaction byte count
- * @sg_len: number of sg entries.
- * @sg: array of sgs.
- */
-struct at_desc {
-	struct				virt_dma_desc vd;
-	struct				at_dma_chan *atchan;
-	size_t				total_len;
-	unsigned int			sglen;
-	/* Interleaved data */
-	size_t				boundary;
-	size_t				dst_hole;
-	size_t				src_hole;
-
-	/* Memset temporary buffer */
-	bool				memset_buffer;
-	dma_addr_t			memset_paddr;
-	int				*memset_vaddr;
-	struct atdma_sg			sg[];
-};
-
-/*--  Channels  --------------------------------------------------------*/
-/**
- * atc_status - information bits stored in channel status flag
- *
- * Manipulated with atomic operations.
- */
-enum atc_status {
-	ATC_IS_PAUSED = 1,
-	ATC_IS_CYCLIC = 24,
-};
-
-/**
- * struct at_dma_chan - internal representation of an Atmel HDMAC channel
- * @vc: virtual dma channel entry.
- * @atdma: pointer to the driver data.
- * @ch_regs: memory mapped register base
- * @mask: channel index in a mask
- * @per_if: peripheral interface
- * @mem_if: memory interface
- * @status: transmit status information from irq/prep* functions
- *                to tasklet (use atomic operations)
- * @save_cfg: configuration register that is saved on suspend/resume cycle
- * @save_dscr: for cyclic operations, preserve next descriptor address in
- *             the cyclic list on suspend/resume cycle
- * @dma_sconfig: configuration for slave transfers, passed via
- * .device_config
- * @desc: pointer to the atmel dma descriptor.
- */
-struct at_dma_chan {
-	struct virt_dma_chan	vc;
-	struct at_dma		*atdma;
-	void __iomem		*ch_regs;
-	u8			mask;
-	u8			per_if;
-	u8			mem_if;
-	unsigned long		status;
-	u32			save_cfg;
-	u32			save_dscr;
-	struct dma_slave_config	dma_sconfig;
-	bool			cyclic;
-	struct at_desc		*desc;
-};
-
-#define	channel_readl(atchan, name) \
-	__raw_readl((atchan)->ch_regs + ATC_##name##_OFFSET)
-
-#define	channel_writel(atchan, name, val) \
-	__raw_writel((val), (atchan)->ch_regs + ATC_##name##_OFFSET)
-
-/*
- * Fix sconfig's burst size according to at_hdmac. We need to convert them as:
- * 1 -> 0, 4 -> 1, 8 -> 2, 16 -> 3, 32 -> 4, 64 -> 5, 128 -> 6, 256 -> 7.
- *
- * This can be done by finding most significant bit set.
- */
-static inline void convert_burst(u32 *maxburst)
-{
-	if (*maxburst > 1)
-		*maxburst = fls(*maxburst) - 2;
-	else
-		*maxburst = 0;
-}
-
-/*
- * Fix sconfig's bus width according to at_hdmac.
- * 1 byte -> 0, 2 bytes -> 1, 4 bytes -> 2.
- */
-static inline u8 convert_buswidth(enum dma_slave_buswidth addr_width)
-{
-	switch (addr_width) {
-	case DMA_SLAVE_BUSWIDTH_2_BYTES:
-		return 1;
-	case DMA_SLAVE_BUSWIDTH_4_BYTES:
-		return 2;
-	default:
-		/* For 1 byte width or fallback */
-		return 0;
-	}
-}
-
-/*--  Controller  ------------------------------------------------------*/
-/**
- * struct at_dma - internal representation of an Atmel HDMA Controller
- * @dma_device: dmaengine dma_device object members
- * @atdma_devtype: identifier of DMA controller compatibility
- * @ch_regs: memory mapped register base
- * @clk: dma controller clock
- * @save_imr: interrupt mask register that is saved on suspend/resume cycle
- * @all_chan_mask: all channels availlable in a mask
- * @lli_pool: hw lli table
- * @chan: channels table to store at_dma_chan structures
- */
-struct at_dma {
-	struct dma_device	dma_device;
-	void __iomem		*regs;
-	struct clk		*clk;
-	u32			save_imr;
-
-	u8			all_chan_mask;
-
-	struct dma_pool		*lli_pool;
-	struct dma_pool		*memset_pool;
-	/* AT THE END channels table */
-	struct at_dma_chan	chan[];
-};
-
-#define	dma_readl(atdma, name) \
-	__raw_readl((atdma)->regs + AT_DMA_##name)
-#define	dma_writel(atdma, name, val) \
-	__raw_writel((val), (atdma)->regs + AT_DMA_##name)
-
-static inline struct at_desc *to_atdma_desc(struct dma_async_tx_descriptor *t)
-{
-	return container_of(t, struct at_desc, vd.tx);
-}
-
-static inline struct at_dma_chan *to_at_dma_chan(struct dma_chan *chan)
-{
-	return container_of(chan, struct at_dma_chan, vc.chan);
-}
-
-static inline struct at_dma *to_at_dma(struct dma_device *ddev)
-{
-	return container_of(ddev, struct at_dma, dma_device);
-}
-
-/*--  Helper functions  ------------------------------------------------*/
-static struct device *chan2dev(struct dma_chan *chan)
-{
-	return &chan->dev->device;
-}
-
-#if defined(VERBOSE_DEBUG)
-static void vdbg_dump_regs(struct at_dma_chan *atchan)
-{
-	struct at_dma	*atdma = to_at_dma(atchan->vc.chan.device);
-
-	dev_err(chan2dev(&atchan->vc.chan),
-		"  channel %d : imr = 0x%x, chsr = 0x%x\n",
-		atchan->vc.chan.chan_id,
-		dma_readl(atdma, EBCIMR),
-		dma_readl(atdma, CHSR));
-
-	dev_err(chan2dev(&atchan->vc.chan),
-		"  channel: s0x%x d0x%x ctrl0x%x:0x%x cfg0x%x l0x%x\n",
-		channel_readl(atchan, SADDR),
-		channel_readl(atchan, DADDR),
-		channel_readl(atchan, CTRLA),
-		channel_readl(atchan, CTRLB),
-		channel_readl(atchan, CFG),
-		channel_readl(atchan, DSCR));
-}
-#else
-static void vdbg_dump_regs(struct at_dma_chan *atchan) {}
-#endif
-
-static void atc_dump_lli(struct at_dma_chan *atchan, struct at_lli *lli)
-{
-	dev_crit(chan2dev(&atchan->vc.chan),
-		 "desc: s%pad d%pad ctrl0x%x:0x%x l%pad\n",
-		 &lli->saddr, &lli->daddr,
-		 lli->ctrla, lli->ctrlb, &lli->dscr);
-}
-
-static void atc_setup_irq(struct at_dma *atdma, int chan_id, int on)
-{
-	u32 ebci;
-
-	/* enable interrupts on buffer transfer completion & error */
-	ebci =    AT_DMA_BTC(chan_id)
-		| AT_DMA_ERR(chan_id);
-	if (on)
-		dma_writel(atdma, EBCIER, ebci);
-	else
-		dma_writel(atdma, EBCIDR, ebci);
-}
-
-static void atc_enable_chan_irq(struct at_dma *atdma, int chan_id)
-{
-	atc_setup_irq(atdma, chan_id, 1);
-}
-
-static void atc_disable_chan_irq(struct at_dma *atdma, int chan_id)
-{
-	atc_setup_irq(atdma, chan_id, 0);
-}
-
-/**
- * atc_chan_is_enabled - test if given channel is enabled
- * @atchan: channel we want to test status
- */
-static inline int atc_chan_is_enabled(struct at_dma_chan *atchan)
-{
-	struct at_dma *atdma = to_at_dma(atchan->vc.chan.device);
-
-	return !!(dma_readl(atdma, CHSR) & atchan->mask);
-}
-
-/**
- * atc_chan_is_paused - test channel pause/resume status
- * @atchan: channel we want to test status
- */
-static inline int atc_chan_is_paused(struct at_dma_chan *atchan)
-{
-	return test_bit(ATC_IS_PAUSED, &atchan->status);
-}
-
-/**
- * atc_chan_is_cyclic - test if given channel has cyclic property set
- * @atchan: channel we want to test status
- */
-static inline int atc_chan_is_cyclic(struct at_dma_chan *atchan)
-{
-	return test_bit(ATC_IS_CYCLIC, &atchan->status);
-}
-
-/**
- * set_lli_eol - set end-of-link to descriptor so it will end transfer
- * @desc: descriptor, signle or at the end of a chain, to end chain on
- * @i: index of the atmel scatter gather entry that is at the end of the chain.
- */
-static void set_lli_eol(struct at_desc *desc, unsigned int i)
-{
-	u32 ctrlb = desc->sg[i].lli->ctrlb;
-
-	ctrlb &= ~ATC_IEN;
-	ctrlb |= ATC_SRC_DSCR_DIS | ATC_DST_DSCR_DIS;
-
-	desc->sg[i].lli->ctrlb = ctrlb;
-	desc->sg[i].lli->dscr = 0;
-}
-
-#define	ATC_DEFAULT_CFG		FIELD_PREP(ATC_FIFOCFG, ATC_FIFOCFG_HALFFIFO)
-#define	ATC_DEFAULT_CTRLB	(FIELD_PREP(ATC_SIF, AT_DMA_MEM_IF) | \
-				 FIELD_PREP(ATC_DIF, AT_DMA_MEM_IF))
+#define	ATC_DEFAULT_CFG		(ATC_FIFOCFG_HALFFIFO)
+#define	ATC_DEFAULT_CTRLB	(ATC_SIF(AT_DMA_MEM_IF) \
+				|ATC_DIF(AT_DMA_MEM_IF))
 #define ATC_DMA_BUSWIDTHS\
 	(BIT(DMA_SLAVE_BUSWIDTH_UNDEFINED) |\
 	BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\
@@ -508,6 +74,13 @@ struct at_dma_slave {
 	u32			cfg;
 };
 
+/* prototypes */
+static dma_cookie_t atc_tx_submit(struct dma_async_tx_descriptor *tx);
+static void atc_issue_pending(struct dma_chan *chan);
+
+
+/*----------------------------------------------------------------------*/
+
 static inline unsigned int atc_get_xfer_width(dma_addr_t src, dma_addr_t dst,
 						size_t len)
 {
@@ -523,72 +96,192 @@ static inline unsigned int atc_get_xfer_
 	return width;
 }
 
-static void atdma_lli_chain(struct at_desc *desc, unsigned int i)
+static struct at_desc *atc_first_active(struct at_dma_chan *atchan)
+{
+	return list_first_entry(&atchan->active_list,
+				struct at_desc, desc_node);
+}
+
+static struct at_desc *atc_first_queued(struct at_dma_chan *atchan)
+{
+	return list_first_entry(&atchan->queue,
+				struct at_desc, desc_node);
+}
+
+/**
+ * atc_alloc_descriptor - allocate and return an initialized descriptor
+ * @chan: the channel to allocate descriptors for
+ * @gfp_flags: GFP allocation flags
+ *
+ * Note: The ack-bit is positioned in the descriptor flag at creation time
+ *       to make initial allocation more convenient. This bit will be cleared
+ *       and control will be given to client at usage time (during
+ *       preparation functions).
+ */
+static struct at_desc *atc_alloc_descriptor(struct dma_chan *chan,
+					    gfp_t gfp_flags)
+{
+	struct at_desc	*desc = NULL;
+	struct at_dma	*atdma = to_at_dma(chan->device);
+	dma_addr_t phys;
+
+	desc = dma_pool_zalloc(atdma->dma_desc_pool, gfp_flags, &phys);
+	if (desc) {
+		INIT_LIST_HEAD(&desc->tx_list);
+		dma_async_tx_descriptor_init(&desc->txd, chan);
+		/* txd.flags will be overwritten in prep functions */
+		desc->txd.flags = DMA_CTRL_ACK;
+		desc->txd.tx_submit = atc_tx_submit;
+		desc->txd.phys = phys;
+	}
+
+	return desc;
+}
+
+/**
+ * atc_desc_get - get an unused descriptor from free_list
+ * @atchan: channel we want a new descriptor for
+ */
+static struct at_desc *atc_desc_get(struct at_dma_chan *atchan)
+{
+	struct at_desc *desc, *_desc;
+	struct at_desc *ret = NULL;
+	unsigned long flags;
+	unsigned int i = 0;
+
+	spin_lock_irqsave(&atchan->lock, flags);
+	list_for_each_entry_safe(desc, _desc, &atchan->free_list, desc_node) {
+		i++;
+		if (async_tx_test_ack(&desc->txd)) {
+			list_del(&desc->desc_node);
+			ret = desc;
+			break;
+		}
+		dev_dbg(chan2dev(&atchan->chan_common),
+				"desc %p not ACKed\n", desc);
+	}
+	spin_unlock_irqrestore(&atchan->lock, flags);
+	dev_vdbg(chan2dev(&atchan->chan_common),
+		"scanned %u descriptors on freelist\n", i);
+
+	/* no more descriptor available in initial pool: create one more */
+	if (!ret)
+		ret = atc_alloc_descriptor(&atchan->chan_common, GFP_NOWAIT);
+
+	return ret;
+}
+
+/**
+ * atc_desc_put - move a descriptor, including any children, to the free list
+ * @atchan: channel we work on
+ * @desc: descriptor, at the head of a chain, to move to free list
+ */
+static void atc_desc_put(struct at_dma_chan *atchan, struct at_desc *desc)
 {
-	struct atdma_sg *atdma_sg = &desc->sg[i];
+	if (desc) {
+		struct at_desc *child;
+		unsigned long flags;
 
-	if (i)
-		desc->sg[i - 1].lli->dscr = atdma_sg->lli_phys;
+		spin_lock_irqsave(&atchan->lock, flags);
+		list_for_each_entry(child, &desc->tx_list, desc_node)
+			dev_vdbg(chan2dev(&atchan->chan_common),
+					"moving child desc %p to freelist\n",
+					child);
+		list_splice_init(&desc->tx_list, &atchan->free_list);
+		dev_vdbg(chan2dev(&atchan->chan_common),
+			 "moving desc %p to freelist\n", desc);
+		list_add(&desc->desc_node, &atchan->free_list);
+		spin_unlock_irqrestore(&atchan->lock, flags);
+	}
+}
+
+/**
+ * atc_desc_chain - build chain adding a descriptor
+ * @first: address of first descriptor of the chain
+ * @prev: address of previous descriptor of the chain
+ * @desc: descriptor to queue
+ *
+ * Called from prep_* functions
+ */
+static void atc_desc_chain(struct at_desc **first, struct at_desc **prev,
+			   struct at_desc *desc)
+{
+	if (!(*first)) {
+		*first = desc;
+	} else {
+		/* inform the HW lli about chaining */
+		(*prev)->lli.dscr = desc->txd.phys;
+		/* insert the link descriptor to the LD ring */
+		list_add_tail(&desc->desc_node,
+				&(*first)->tx_list);
+	}
+	*prev = desc;
 }
 
 /**
  * atc_dostart - starts the DMA engine for real
  * @atchan: the channel we want to start
+ * @first: first descriptor in the list we want to begin with
+ *
+ * Called with atchan->lock held and bh disabled
  */
-static void atc_dostart(struct at_dma_chan *atchan)
+static void atc_dostart(struct at_dma_chan *atchan, struct at_desc *first)
 {
-	struct virt_dma_desc *vd = vchan_next_desc(&atchan->vc);
-	struct at_desc *desc;
+	struct at_dma	*atdma = to_at_dma(atchan->chan_common.device);
+
+	/* ASSERT:  channel is idle */
+	if (atc_chan_is_enabled(atchan)) {
+		dev_err(chan2dev(&atchan->chan_common),
+			"BUG: Attempted to start non-idle channel\n");
+		dev_err(chan2dev(&atchan->chan_common),
+			"  channel: s0x%x d0x%x ctrl0x%x:0x%x l0x%x\n",
+			channel_readl(atchan, SADDR),
+			channel_readl(atchan, DADDR),
+			channel_readl(atchan, CTRLA),
+			channel_readl(atchan, CTRLB),
+			channel_readl(atchan, DSCR));
 
-	if (!vd) {
-		atchan->desc = NULL;
+		/* The tasklet will hopefully advance the queue... */
 		return;
 	}
 
 	vdbg_dump_regs(atchan);
 
-	list_del(&vd->node);
-	atchan->desc = desc = to_atdma_desc(&vd->tx);
-
 	channel_writel(atchan, SADDR, 0);
 	channel_writel(atchan, DADDR, 0);
 	channel_writel(atchan, CTRLA, 0);
 	channel_writel(atchan, CTRLB, 0);
-	channel_writel(atchan, DSCR, desc->sg[0].lli_phys);
-	channel_writel(atchan, SPIP,
-		       FIELD_PREP(ATC_SPIP_HOLE, desc->src_hole) |
-		       FIELD_PREP(ATC_SPIP_BOUNDARY, desc->boundary));
-	channel_writel(atchan, DPIP,
-		       FIELD_PREP(ATC_DPIP_HOLE, desc->dst_hole) |
-		       FIELD_PREP(ATC_DPIP_BOUNDARY, desc->boundary));
-
-	/* Don't allow CPU to reorder channel enable. */
-	wmb();
-	dma_writel(atchan->atdma, CHER, atchan->mask);
+	channel_writel(atchan, DSCR, first->txd.phys);
+	channel_writel(atchan, SPIP, ATC_SPIP_HOLE(first->src_hole) |
+		       ATC_SPIP_BOUNDARY(first->boundary));
+	channel_writel(atchan, DPIP, ATC_DPIP_HOLE(first->dst_hole) |
+		       ATC_DPIP_BOUNDARY(first->boundary));
+	dma_writel(atdma, CHER, atchan->mask);
 
 	vdbg_dump_regs(atchan);
 }
 
-static void atdma_desc_free(struct virt_dma_desc *vd)
+/*
+ * atc_get_desc_by_cookie - get the descriptor of a cookie
+ * @atchan: the DMA channel
+ * @cookie: the cookie to get the descriptor for
+ */
+static struct at_desc *atc_get_desc_by_cookie(struct at_dma_chan *atchan,
+						dma_cookie_t cookie)
 {
-	struct at_dma *atdma = to_at_dma(vd->tx.chan->device);
-	struct at_desc *desc = to_atdma_desc(&vd->tx);
-	unsigned int i;
-
-	for (i = 0; i < desc->sglen; i++) {
-		if (desc->sg[i].lli)
-			dma_pool_free(atdma->lli_pool, desc->sg[i].lli,
-				      desc->sg[i].lli_phys);
+	struct at_desc *desc, *_desc;
+
+	list_for_each_entry_safe(desc, _desc, &atchan->queue, desc_node) {
+		if (desc->txd.cookie == cookie)
+			return desc;
 	}
 
-	/* If the transfer was a memset, free our temporary buffer */
-	if (desc->memset_buffer) {
-		dma_pool_free(atdma->memset_pool, desc->memset_vaddr,
-			      desc->memset_paddr);
-		desc->memset_buffer = false;
+	list_for_each_entry_safe(desc, _desc, &atchan->active_list, desc_node) {
+		if (desc->txd.cookie == cookie)
+			return desc;
 	}
 
-	kfree(desc);
+	return NULL;
 }
 
 /**
@@ -598,10 +291,10 @@ static void atdma_desc_free(struct virt_
  * @current_len: the number of bytes left before reading CTRLA
  * @ctrla: the value of CTRLA
  */
-static inline u32 atc_calc_bytes_left(u32 current_len, u32 ctrla)
+static inline int atc_calc_bytes_left(int current_len, u32 ctrla)
 {
-	u32 btsize = FIELD_GET(ATC_BTSIZE, ctrla);
-	u32 src_width = FIELD_GET(ATC_SRC_WIDTH, ctrla);
+	u32 btsize = (ctrla & ATC_BTSIZE_MAX);
+	u32 src_width = ATC_REG_TO_SRC_WIDTH(ctrla);
 
 	/*
 	 * According to the datasheet, when reading the Control A Register
@@ -613,153 +306,277 @@ static inline u32 atc_calc_bytes_left(u3
 }
 
 /**
- * atc_get_llis_residue - Get residue for a hardware linked list transfer
- *
- * Calculate the residue by removing the length of the Linked List Item (LLI)
- * already transferred from the total length. To get the current LLI we can use
- * the value of the channel's DSCR register and compare it against the DSCR
- * value of each LLI.
- *
- * The CTRLA register provides us with the amount of data already read from the
- * source for the LLI. So we can compute a more accurate residue by also
- * removing the number of bytes corresponding to this amount of data.
- *
- * However, the DSCR and CTRLA registers cannot be read both atomically. Hence a
- * race condition may occur: the first read register may refer to one LLI
- * whereas the second read may refer to a later LLI in the list because of the
- * DMA transfer progression inbetween the two reads.
- *
- * One solution could have been to pause the DMA transfer, read the DSCR and
- * CTRLA then resume the DMA transfer. Nonetheless, this approach presents some
- * drawbacks:
- * - If the DMA transfer is paused, RX overruns or TX underruns are more likey
- *   to occur depending on the system latency. Taking the USART driver as an
- *   example, it uses a cyclic DMA transfer to read data from the Receive
- *   Holding Register (RHR) to avoid RX overruns since the RHR is not protected
- *   by any FIFO on most Atmel SoCs. So pausing the DMA transfer to compute the
- *   residue would break the USART driver design.
- * - The atc_pause() function masks interrupts but we'd rather avoid to do so
- * for system latency purpose.
- *
- * Then we'd rather use another solution: the DSCR is read a first time, the
- * CTRLA is read in turn, next the DSCR is read a second time. If the two
- * consecutive read values of the DSCR are the same then we assume both refers
- * to the very same LLI as well as the CTRLA value read inbetween does. For
- * cyclic tranfers, the assumption is that a full loop is "not so fast". If the
- * two DSCR values are different, we read again the CTRLA then the DSCR till two
- * consecutive read values from DSCR are equal or till the maximum trials is
- * reach. This algorithm is very unlikely not to find a stable value for DSCR.
- * @atchan: pointer to an atmel hdmac channel.
- * @desc: pointer to the descriptor for which the residue is calculated.
- * @residue: residue to be set to dma_tx_state.
- * Returns 0 on success, -errno otherwise.
- */
-static int atc_get_llis_residue(struct at_dma_chan *atchan,
-				struct at_desc *desc, u32 *residue)
-{
-	u32 len, ctrla, dscr;
-	unsigned int i;
-
-	len = desc->total_len;
-	dscr = channel_readl(atchan, DSCR);
-	rmb(); /* ensure DSCR is read before CTRLA */
-	ctrla = channel_readl(atchan, CTRLA);
-	for (i = 0; i < ATC_MAX_DSCR_TRIALS; ++i) {
-		u32 new_dscr;
+ * atc_get_bytes_left - get the number of bytes residue for a cookie
+ * @chan: DMA channel
+ * @cookie: transaction identifier to check status of
+ */
+static int atc_get_bytes_left(struct dma_chan *chan, dma_cookie_t cookie)
+{
+	struct at_dma_chan      *atchan = to_at_dma_chan(chan);
+	struct at_desc *desc_first = atc_first_active(atchan);
+	struct at_desc *desc;
+	int ret;
+	u32 ctrla, dscr, trials;
+
+	/*
+	 * If the cookie doesn't match to the currently running transfer then
+	 * we can return the total length of the associated DMA transfer,
+	 * because it is still queued.
+	 */
+	desc = atc_get_desc_by_cookie(atchan, cookie);
+	if (desc == NULL)
+		return -EINVAL;
+	else if (desc != desc_first)
+		return desc->total_len;
+
+	/* cookie matches to the currently running transfer */
+	ret = desc_first->total_len;
 
-		rmb(); /* ensure DSCR is read after CTRLA */
-		new_dscr = channel_readl(atchan, DSCR);
+	if (desc_first->lli.dscr) {
+		/* hardware linked list transfer */
 
 		/*
-		 * If the DSCR register value has not changed inside the DMA
-		 * controller since the previous read, we assume that both the
-		 * dscr and ctrla values refers to the very same descriptor.
+		 * Calculate the residue by removing the length of the child
+		 * descriptors already transferred from the total length.
+		 * To get the current child descriptor we can use the value of
+		 * the channel's DSCR register and compare it against the value
+		 * of the hardware linked list structure of each child
+		 * descriptor.
+		 *
+		 * The CTRLA register provides us with the amount of data
+		 * already read from the source for the current child
+		 * descriptor. So we can compute a more accurate residue by also
+		 * removing the number of bytes corresponding to this amount of
+		 * data.
+		 *
+		 * However, the DSCR and CTRLA registers cannot be read both
+		 * atomically. Hence a race condition may occur: the first read
+		 * register may refer to one child descriptor whereas the second
+		 * read may refer to a later child descriptor in the list
+		 * because of the DMA transfer progression inbetween the two
+		 * reads.
+		 *
+		 * One solution could have been to pause the DMA transfer, read
+		 * the DSCR and CTRLA then resume the DMA transfer. Nonetheless,
+		 * this approach presents some drawbacks:
+		 * - If the DMA transfer is paused, RX overruns or TX underruns
+		 *   are more likey to occur depending on the system latency.
+		 *   Taking the USART driver as an example, it uses a cyclic DMA
+		 *   transfer to read data from the Receive Holding Register
+		 *   (RHR) to avoid RX overruns since the RHR is not protected
+		 *   by any FIFO on most Atmel SoCs. So pausing the DMA transfer
+		 *   to compute the residue would break the USART driver design.
+		 * - The atc_pause() function masks interrupts but we'd rather
+		 *   avoid to do so for system latency purpose.
+		 *
+		 * Then we'd rather use another solution: the DSCR is read a
+		 * first time, the CTRLA is read in turn, next the DSCR is read
+		 * a second time. If the two consecutive read values of the DSCR
+		 * are the same then we assume both refers to the very same
+		 * child descriptor as well as the CTRLA value read inbetween
+		 * does. For cyclic tranfers, the assumption is that a full loop
+		 * is "not so fast".
+		 * If the two DSCR values are different, we read again the CTRLA
+		 * then the DSCR till two consecutive read values from DSCR are
+		 * equal or till the maxium trials is reach.
+		 * This algorithm is very unlikely not to find a stable value for
+		 * DSCR.
 		 */
-		if (likely(new_dscr == dscr))
-			break;
+
+		dscr = channel_readl(atchan, DSCR);
+		rmb(); /* ensure DSCR is read before CTRLA */
+		ctrla = channel_readl(atchan, CTRLA);
+		for (trials = 0; trials < ATC_MAX_DSCR_TRIALS; ++trials) {
+			u32 new_dscr;
+
+			rmb(); /* ensure DSCR is read after CTRLA */
+			new_dscr = channel_readl(atchan, DSCR);
+
+			/*
+			 * If the DSCR register value has not changed inside the
+			 * DMA controller since the previous read, we assume
+			 * that both the dscr and ctrla values refers to the
+			 * very same descriptor.
+			 */
+			if (likely(new_dscr == dscr))
+				break;
+
+			/*
+			 * DSCR has changed inside the DMA controller, so the
+			 * previouly read value of CTRLA may refer to an already
+			 * processed descriptor hence could be outdated.
+			 * We need to update ctrla to match the current
+			 * descriptor.
+			 */
+			dscr = new_dscr;
+			rmb(); /* ensure DSCR is read before CTRLA */
+			ctrla = channel_readl(atchan, CTRLA);
+		}
+		if (unlikely(trials >= ATC_MAX_DSCR_TRIALS))
+			return -ETIMEDOUT;
+
+		/* for the first descriptor we can be more accurate */
+		if (desc_first->lli.dscr == dscr)
+			return atc_calc_bytes_left(ret, ctrla);
+
+		ret -= desc_first->len;
+		list_for_each_entry(desc, &desc_first->tx_list, desc_node) {
+			if (desc->lli.dscr == dscr)
+				break;
+
+			ret -= desc->len;
+		}
 
 		/*
-		 * DSCR has changed inside the DMA controller, so the previouly
-		 * read value of CTRLA may refer to an already processed
-		 * descriptor hence could be outdated. We need to update ctrla
-		 * to match the current descriptor.
+		 * For the current descriptor in the chain we can calculate
+		 * the remaining bytes using the channel's register.
 		 */
-		dscr = new_dscr;
-		rmb(); /* ensure DSCR is read before CTRLA */
+		ret = atc_calc_bytes_left(ret, ctrla);
+	} else {
+		/* single transfer */
 		ctrla = channel_readl(atchan, CTRLA);
+		ret = atc_calc_bytes_left(ret, ctrla);
 	}
-	if (unlikely(i == ATC_MAX_DSCR_TRIALS))
-		return -ETIMEDOUT;
 
-	/* For the first descriptor we can be more accurate. */
-	if (desc->sg[0].lli->dscr == dscr) {
-		*residue = atc_calc_bytes_left(len, ctrla);
-		return 0;
-	}
-	len -= desc->sg[0].len;
+	return ret;
+}
 
-	for (i = 1; i < desc->sglen; i++) {
-		if (desc->sg[i].lli && desc->sg[i].lli->dscr == dscr)
-			break;
-		len -= desc->sg[i].len;
+/**
+ * atc_chain_complete - finish work for one transaction chain
+ * @atchan: channel we work on
+ * @desc: descriptor at the head of the chain we want do complete
+ */
+static void
+atc_chain_complete(struct at_dma_chan *atchan, struct at_desc *desc)
+{
+	struct dma_async_tx_descriptor	*txd = &desc->txd;
+	struct at_dma			*atdma = to_at_dma(atchan->chan_common.device);
+	unsigned long flags;
+
+	dev_vdbg(chan2dev(&atchan->chan_common),
+		"descriptor %u complete\n", txd->cookie);
+
+	spin_lock_irqsave(&atchan->lock, flags);
+
+	/* mark the descriptor as complete for non cyclic cases only */
+	if (!atc_chan_is_cyclic(atchan))
+		dma_cookie_complete(txd);
+
+	/* If the transfer was a memset, free our temporary buffer */
+	if (desc->memset_buffer) {
+		dma_pool_free(atdma->memset_pool, desc->memset_vaddr,
+			      desc->memset_paddr);
+		desc->memset_buffer = false;
 	}
 
+	/* move children to free_list */
+	list_splice_init(&desc->tx_list, &atchan->free_list);
+	/* move myself to free_list */
+	list_move(&desc->desc_node, &atchan->free_list);
+
+	spin_unlock_irqrestore(&atchan->lock, flags);
+
+	dma_descriptor_unmap(txd);
+	/* for cyclic transfers,
+	 * no need to replay callback function while stopping */
+	if (!atc_chan_is_cyclic(atchan))
+		dmaengine_desc_get_callback_invoke(txd, NULL);
+
+	dma_run_dependencies(txd);
+}
+
+/**
+ * atc_complete_all - finish work for all transactions
+ * @atchan: channel to complete transactions for
+ *
+ * Eventually submit queued descriptors if any
+ *
+ * Assume channel is idle while calling this function
+ * Called with atchan->lock held and bh disabled
+ */
+static void atc_complete_all(struct at_dma_chan *atchan)
+{
+	struct at_desc *desc, *_desc;
+	LIST_HEAD(list);
+	unsigned long flags;
+
+	dev_vdbg(chan2dev(&atchan->chan_common), "complete all\n");
+
+	spin_lock_irqsave(&atchan->lock, flags);
+
 	/*
-	 * For the current LLI in the chain we can calculate the remaining bytes
-	 * using the channel's CTRLA register.
+	 * Submit queued descriptors ASAP, i.e. before we go through
+	 * the completed ones.
 	 */
-	*residue = atc_calc_bytes_left(len, ctrla);
-	return 0;
+	if (!list_empty(&atchan->queue))
+		atc_dostart(atchan, atc_first_queued(atchan));
+	/* empty active_list now it is completed */
+	list_splice_init(&atchan->active_list, &list);
+	/* empty queue list by moving descriptors (if any) to active_list */
+	list_splice_init(&atchan->queue, &atchan->active_list);
 
+	spin_unlock_irqrestore(&atchan->lock, flags);
+
+	list_for_each_entry_safe(desc, _desc, &list, desc_node)
+		atc_chain_complete(atchan, desc);
 }
 
 /**
- * atc_get_residue - get the number of bytes residue for a cookie.
- * The residue is passed by address and updated on success.
- * @chan: DMA channel
- * @cookie: transaction identifier to check status of
- * @residue: residue to be updated.
- * Return 0 on success, -errono otherwise.
+ * atc_advance_work - at the end of a transaction, move forward
+ * @atchan: channel where the transaction ended
  */
-static int atc_get_residue(struct dma_chan *chan, dma_cookie_t cookie,
-			   u32 *residue)
+static void atc_advance_work(struct at_dma_chan *atchan)
 {
-	struct at_dma_chan *atchan = to_at_dma_chan(chan);
-	struct virt_dma_desc *vd;
-	struct at_desc *desc = NULL;
-	u32 len, ctrla;
-
-	vd = vchan_find_desc(&atchan->vc, cookie);
-	if (vd)
-		desc = to_atdma_desc(&vd->tx);
-	else if (atchan->desc && atchan->desc->vd.tx.cookie == cookie)
-		desc = atchan->desc;
+	unsigned long flags;
+	int ret;
 
-	if (!desc)
-		return -EINVAL;
+	dev_vdbg(chan2dev(&atchan->chan_common), "advance_work\n");
 
-	if (desc->sg[0].lli->dscr)
-		/* hardware linked list transfer */
-		return atc_get_llis_residue(atchan, desc, residue);
+	spin_lock_irqsave(&atchan->lock, flags);
+	ret = atc_chan_is_enabled(atchan);
+	spin_unlock_irqrestore(&atchan->lock, flags);
+	if (ret)
+		return;
 
-	/* single transfer */
-	len = desc->total_len;
-	ctrla = channel_readl(atchan, CTRLA);
-	*residue = atc_calc_bytes_left(len, ctrla);
-	return 0;
+	if (list_empty(&atchan->active_list) ||
+	    list_is_singular(&atchan->active_list))
+		return atc_complete_all(atchan);
+
+	atc_chain_complete(atchan, atc_first_active(atchan));
+
+	/* advance work */
+	spin_lock_irqsave(&atchan->lock, flags);
+	atc_dostart(atchan, atc_first_active(atchan));
+	spin_unlock_irqrestore(&atchan->lock, flags);
 }
 
+
 /**
  * atc_handle_error - handle errors reported by DMA controller
- * @atchan: channel where error occurs.
- * @i: channel index
+ * @atchan: channel where error occurs
  */
-static void atc_handle_error(struct at_dma_chan *atchan, unsigned int i)
+static void atc_handle_error(struct at_dma_chan *atchan)
 {
-	struct at_desc *desc = atchan->desc;
+	struct at_desc *bad_desc;
+	struct at_desc *child;
+	unsigned long flags;
+
+	spin_lock_irqsave(&atchan->lock, flags);
+	/*
+	 * The descriptor currently at the head of the active list is
+	 * broked. Since we don't have any way to report errors, we'll
+	 * just have to scream loudly and try to carry on.
+	 */
+	bad_desc = atc_first_active(atchan);
+	list_del_init(&bad_desc->desc_node);
 
-	/* Disable channel on AHB error */
-	dma_writel(atchan->atdma, CHDR, AT_DMA_RES(i) | atchan->mask);
+	/* As we are stopped, take advantage to push queued descriptors
+	 * in active_list */
+	list_splice_init(&atchan->queue, atchan->active_list.prev);
+
+	/* Try to restart the controller */
+	if (!list_empty(&atchan->active_list))
+		atc_dostart(atchan, atc_first_active(atchan));
 
 	/*
 	 * KERN_CRITICAL may seem harsh, but since this only happens
@@ -768,42 +585,54 @@ static void atc_handle_error(struct at_d
 	 * controller flagged an error instead of scribbling over
 	 * random memory locations.
 	 */
-	dev_crit(chan2dev(&atchan->vc.chan), "Bad descriptor submitted for DMA!\n");
-	dev_crit(chan2dev(&atchan->vc.chan), "cookie: %d\n",
-		 desc->vd.tx.cookie);
-	for (i = 0; i < desc->sglen; i++)
-		atc_dump_lli(atchan, desc->sg[i].lli);
+	dev_crit(chan2dev(&atchan->chan_common),
+			"Bad descriptor submitted for DMA!\n");
+	dev_crit(chan2dev(&atchan->chan_common),
+			"  cookie: %d\n", bad_desc->txd.cookie);
+	atc_dump_lli(atchan, &bad_desc->lli);
+	list_for_each_entry(child, &bad_desc->tx_list, desc_node)
+		atc_dump_lli(atchan, &child->lli);
+
+	spin_unlock_irqrestore(&atchan->lock, flags);
+
+	/* Pretend the descriptor completed successfully */
+	atc_chain_complete(atchan, bad_desc);
 }
 
-static void atdma_handle_chan_done(struct at_dma_chan *atchan, u32 pending,
-				   unsigned int i)
+/**
+ * atc_handle_cyclic - at the end of a period, run callback function
+ * @atchan: channel used for cyclic operations
+ */
+static void atc_handle_cyclic(struct at_dma_chan *atchan)
 {
-	struct at_desc *desc;
+	struct at_desc			*first = atc_first_active(atchan);
+	struct dma_async_tx_descriptor	*txd = &first->txd;
 
-	spin_lock(&atchan->vc.lock);
-	desc = atchan->desc;
+	dev_vdbg(chan2dev(&atchan->chan_common),
+			"new cyclic period llp 0x%08x\n",
+			channel_readl(atchan, DSCR));
 
-	if (desc) {
-		if (pending & AT_DMA_ERR(i)) {
-			atc_handle_error(atchan, i);
-			/* Pretend the descriptor completed successfully */
-		}
+	dmaengine_desc_get_callback_invoke(txd, NULL);
+}
 
-		if (atc_chan_is_cyclic(atchan)) {
-			vchan_cyclic_callback(&desc->vd);
-		} else {
-			vchan_cookie_complete(&desc->vd);
-			atchan->desc = NULL;
-			if (!(atc_chan_is_enabled(atchan)))
-				atc_dostart(atchan);
-		}
-	}
-	spin_unlock(&atchan->vc.lock);
+/*--  IRQ & Tasklet  ---------------------------------------------------*/
+
+static void atc_tasklet(struct tasklet_struct *t)
+{
+	struct at_dma_chan *atchan = from_tasklet(atchan, t, tasklet);
+
+	if (test_and_clear_bit(ATC_IS_ERROR, &atchan->status))
+		return atc_handle_error(atchan);
+
+	if (atc_chan_is_cyclic(atchan))
+		return atc_handle_cyclic(atchan);
+
+	atc_advance_work(atchan);
 }
 
 static irqreturn_t at_dma_interrupt(int irq, void *dev_id)
 {
-	struct at_dma		*atdma = dev_id;
+	struct at_dma		*atdma = (struct at_dma *)dev_id;
 	struct at_dma_chan	*atchan;
 	int			i;
 	u32			status, pending, imr;
@@ -817,16 +646,23 @@ static irqreturn_t at_dma_interrupt(int
 		if (!pending)
 			break;
 
-		dev_vdbg(atdma->dma_device.dev,
+		dev_vdbg(atdma->dma_common.dev,
 			"interrupt: status = 0x%08x, 0x%08x, 0x%08x\n",
 			 status, imr, pending);
 
-		for (i = 0; i < atdma->dma_device.chancnt; i++) {
+		for (i = 0; i < atdma->dma_common.chancnt; i++) {
 			atchan = &atdma->chan[i];
-			if (!(pending & (AT_DMA_BTC(i) | AT_DMA_ERR(i))))
-				continue;
-			atdma_handle_chan_done(atchan, pending, i);
-			ret = IRQ_HANDLED;
+			if (pending & (AT_DMA_BTC(i) | AT_DMA_ERR(i))) {
+				if (pending & AT_DMA_ERR(i)) {
+					/* Disable channel on AHB error */
+					dma_writel(atdma, CHDR,
+						AT_DMA_RES(i) | atchan->mask);
+					/* Give information to tasklet */
+					set_bit(ATC_IS_ERROR, &atchan->status);
+				}
+				tasklet_schedule(&atchan->tasklet);
+				ret = IRQ_HANDLED;
+			}
 		}
 
 	} while (pending);
@@ -834,7 +670,43 @@ static irqreturn_t at_dma_interrupt(int
 	return ret;
 }
 
+
 /*--  DMA Engine API  --------------------------------------------------*/
+
+/**
+ * atc_tx_submit - set the prepared descriptor(s) to be executed by the engine
+ * @tx: descriptor at the head of the transaction chain
+ *
+ * Queue chain if DMA engine is working already
+ *
+ * Cookie increment and adding to active_list or queue must be atomic
+ */
+static dma_cookie_t atc_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct at_desc		*desc = txd_to_at_desc(tx);
+	struct at_dma_chan	*atchan = to_at_dma_chan(tx->chan);
+	dma_cookie_t		cookie;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&atchan->lock, flags);
+	cookie = dma_cookie_assign(tx);
+
+	if (list_empty(&atchan->active_list)) {
+		dev_vdbg(chan2dev(tx->chan), "tx_submit: started %u\n",
+				desc->txd.cookie);
+		atc_dostart(atchan, desc);
+		list_add_tail(&desc->desc_node, &atchan->active_list);
+	} else {
+		dev_vdbg(chan2dev(tx->chan), "tx_submit: queued %u\n",
+				desc->txd.cookie);
+		list_add_tail(&desc->desc_node, &atchan->queue);
+	}
+
+	spin_unlock_irqrestore(&atchan->lock, flags);
+
+	return cookie;
+}
+
 /**
  * atc_prep_dma_interleaved - prepare memory to memory interleaved operation
  * @chan: the channel to prepare operation on
@@ -846,12 +718,9 @@ atc_prep_dma_interleaved(struct dma_chan
 			 struct dma_interleaved_template *xt,
 			 unsigned long flags)
 {
-	struct at_dma		*atdma = to_at_dma(chan->device);
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct data_chunk	*first;
-	struct atdma_sg		*atdma_sg;
-	struct at_desc		*desc;
-	struct at_lli		*lli;
+	struct at_desc		*desc = NULL;
 	size_t			xfer_count;
 	unsigned int		dwidth;
 	u32			ctrla;
@@ -890,7 +759,8 @@ atc_prep_dma_interleaved(struct dma_chan
 		len += chunk->size;
 	}
 
-	dwidth = atc_get_xfer_width(xt->src_start, xt->dst_start, len);
+	dwidth = atc_get_xfer_width(xt->src_start,
+				    xt->dst_start, len);
 
 	xfer_count = len >> dwidth;
 	if (xfer_count > ATC_BTSIZE_MAX) {
@@ -898,43 +768,42 @@ atc_prep_dma_interleaved(struct dma_chan
 		return NULL;
 	}
 
-	ctrla = FIELD_PREP(ATC_SRC_WIDTH, dwidth) |
-		FIELD_PREP(ATC_DST_WIDTH, dwidth);
-
-	ctrlb = ATC_DEFAULT_CTRLB | ATC_IEN |
-		FIELD_PREP(ATC_SRC_ADDR_MODE, ATC_SRC_ADDR_MODE_INCR) |
-		FIELD_PREP(ATC_DST_ADDR_MODE, ATC_DST_ADDR_MODE_INCR) |
-		ATC_SRC_PIP | ATC_DST_PIP |
-		FIELD_PREP(ATC_FC, ATC_FC_MEM2MEM);
-
-	desc = kzalloc(struct_size(desc, sg, 1), GFP_ATOMIC);
-	if (!desc)
-		return NULL;
-	desc->sglen = 1;
+	ctrla = ATC_SRC_WIDTH(dwidth) |
+		ATC_DST_WIDTH(dwidth);
 
-	atdma_sg = desc->sg;
-	atdma_sg->lli = dma_pool_alloc(atdma->lli_pool, GFP_NOWAIT,
-				       &atdma_sg->lli_phys);
-	if (!atdma_sg->lli) {
-		kfree(desc);
+	ctrlb =   ATC_DEFAULT_CTRLB | ATC_IEN
+		| ATC_SRC_ADDR_MODE_INCR
+		| ATC_DST_ADDR_MODE_INCR
+		| ATC_SRC_PIP
+		| ATC_DST_PIP
+		| ATC_FC_MEM2MEM;
+
+	/* create the transfer */
+	desc = atc_desc_get(atchan);
+	if (!desc) {
+		dev_err(chan2dev(chan),
+			"%s: couldn't allocate our descriptor\n", __func__);
 		return NULL;
 	}
-	lli = atdma_sg->lli;
 
-	lli->saddr = xt->src_start;
-	lli->daddr = xt->dst_start;
-	lli->ctrla = ctrla | xfer_count;
-	lli->ctrlb = ctrlb;
+	desc->lli.saddr = xt->src_start;
+	desc->lli.daddr = xt->dst_start;
+	desc->lli.ctrla = ctrla | xfer_count;
+	desc->lli.ctrlb = ctrlb;
 
 	desc->boundary = first->size >> dwidth;
 	desc->dst_hole = (dmaengine_get_dst_icg(xt, first) >> dwidth) + 1;
 	desc->src_hole = (dmaengine_get_src_icg(xt, first) >> dwidth) + 1;
 
-	atdma_sg->len = len;
-	desc->total_len = len;
+	desc->txd.cookie = -EBUSY;
+	desc->total_len = desc->len = len;
+
+	/* set end-of-link to the last link descriptor of list*/
+	set_desc_eol(desc);
 
-	set_lli_eol(desc, 0);
-	return vchan_tx_prep(&atchan->vc, &desc->vd, flags);
+	desc->txd.flags = flags; /* client is in control of this ack */
+
+	return &desc->txd;
 }
 
 /**
@@ -949,36 +818,29 @@ static struct dma_async_tx_descriptor *
 atc_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
 		size_t len, unsigned long flags)
 {
-	struct at_dma		*atdma = to_at_dma(chan->device);
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct at_desc		*desc = NULL;
+	struct at_desc		*first = NULL;
+	struct at_desc		*prev = NULL;
 	size_t			xfer_count;
 	size_t			offset;
-	size_t			sg_len;
 	unsigned int		src_width;
 	unsigned int		dst_width;
-	unsigned int		i;
 	u32			ctrla;
 	u32			ctrlb;
 
-	dev_dbg(chan2dev(chan), "prep_dma_memcpy: d%pad s%pad l0x%zx f0x%lx\n",
-		&dest, &src, len, flags);
+	dev_vdbg(chan2dev(chan), "prep_dma_memcpy: d%pad s%pad l0x%zx f0x%lx\n",
+			&dest, &src, len, flags);
 
 	if (unlikely(!len)) {
-		dev_err(chan2dev(chan), "prep_dma_memcpy: length is zero!\n");
+		dev_dbg(chan2dev(chan), "prep_dma_memcpy: length is zero!\n");
 		return NULL;
 	}
 
-	sg_len = DIV_ROUND_UP(len, ATC_BTSIZE_MAX);
-	desc = kzalloc(struct_size(desc, sg, sg_len), GFP_ATOMIC);
-	if (!desc)
-		return NULL;
-	desc->sglen = sg_len;
-
-	ctrlb = ATC_DEFAULT_CTRLB | ATC_IEN |
-		FIELD_PREP(ATC_SRC_ADDR_MODE, ATC_SRC_ADDR_MODE_INCR) |
-		FIELD_PREP(ATC_DST_ADDR_MODE, ATC_DST_ADDR_MODE_INCR) |
-		FIELD_PREP(ATC_FC, ATC_FC_MEM2MEM);
+	ctrlb =   ATC_DEFAULT_CTRLB | ATC_IEN
+		| ATC_SRC_ADDR_MODE_INCR
+		| ATC_DST_ADDR_MODE_INCR
+		| ATC_FC_MEM2MEM;
 
 	/*
 	 * We can be a lot more clever here, but this should take care
@@ -986,78 +848,82 @@ atc_prep_dma_memcpy(struct dma_chan *cha
 	 */
 	src_width = dst_width = atc_get_xfer_width(src, dest, len);
 
-	ctrla = FIELD_PREP(ATC_SRC_WIDTH, src_width) |
-		FIELD_PREP(ATC_DST_WIDTH, dst_width);
-
-	for (offset = 0, i = 0; offset < len;
-	     offset += xfer_count << src_width, i++) {
-		struct atdma_sg *atdma_sg = &desc->sg[i];
-		struct at_lli *lli;
-
-		atdma_sg->lli = dma_pool_alloc(atdma->lli_pool, GFP_NOWAIT,
-					       &atdma_sg->lli_phys);
-		if (!atdma_sg->lli)
-			goto err_desc_get;
-		lli = atdma_sg->lli;
+	ctrla = ATC_SRC_WIDTH(src_width) |
+		ATC_DST_WIDTH(dst_width);
 
+	for (offset = 0; offset < len; offset += xfer_count << src_width) {
 		xfer_count = min_t(size_t, (len - offset) >> src_width,
-				   ATC_BTSIZE_MAX);
+				ATC_BTSIZE_MAX);
+
+		desc = atc_desc_get(atchan);
+		if (!desc)
+			goto err_desc_get;
 
-		lli->saddr = src + offset;
-		lli->daddr = dest + offset;
-		lli->ctrla = ctrla | xfer_count;
-		lli->ctrlb = ctrlb;
+		desc->lli.saddr = src + offset;
+		desc->lli.daddr = dest + offset;
+		desc->lli.ctrla = ctrla | xfer_count;
+		desc->lli.ctrlb = ctrlb;
 
-		desc->sg[i].len = xfer_count << src_width;
+		desc->txd.cookie = 0;
+		desc->len = xfer_count << src_width;
 
-		atdma_lli_chain(desc, i);
+		atc_desc_chain(&first, &prev, desc);
 	}
 
-	desc->total_len = len;
+	/* First descriptor of the chain embedds additional information */
+	first->txd.cookie = -EBUSY;
+	first->total_len = len;
 
 	/* set end-of-link to the last link descriptor of list*/
-	set_lli_eol(desc, i - 1);
+	set_desc_eol(desc);
+
+	first->txd.flags = flags; /* client is in control of this ack */
 
-	return vchan_tx_prep(&atchan->vc, &desc->vd, flags);
+	return &first->txd;
 
 err_desc_get:
-	atdma_desc_free(&desc->vd);
+	atc_desc_put(atchan, first);
 	return NULL;
 }
 
-static int atdma_create_memset_lli(struct dma_chan *chan,
-				   struct atdma_sg *atdma_sg,
-				   dma_addr_t psrc, dma_addr_t pdst, size_t len)
+static struct at_desc *atc_create_memset_desc(struct dma_chan *chan,
+					      dma_addr_t psrc,
+					      dma_addr_t pdst,
+					      size_t len)
 {
-	struct at_dma *atdma = to_at_dma(chan->device);
-	struct at_lli *lli;
+	struct at_dma_chan *atchan = to_at_dma_chan(chan);
+	struct at_desc *desc;
 	size_t xfer_count;
-	u32 ctrla = FIELD_PREP(ATC_SRC_WIDTH, 2) | FIELD_PREP(ATC_DST_WIDTH, 2);
+
+	u32 ctrla = ATC_SRC_WIDTH(2) | ATC_DST_WIDTH(2);
 	u32 ctrlb = ATC_DEFAULT_CTRLB | ATC_IEN |
-		    FIELD_PREP(ATC_SRC_ADDR_MODE, ATC_SRC_ADDR_MODE_FIXED) |
-		    FIELD_PREP(ATC_DST_ADDR_MODE, ATC_DST_ADDR_MODE_INCR) |
-		    FIELD_PREP(ATC_FC, ATC_FC_MEM2MEM);
+		ATC_SRC_ADDR_MODE_FIXED |
+		ATC_DST_ADDR_MODE_INCR |
+		ATC_FC_MEM2MEM;
 
 	xfer_count = len >> 2;
 	if (xfer_count > ATC_BTSIZE_MAX) {
-		dev_err(chan2dev(chan), "%s: buffer is too big\n", __func__);
-		return -EINVAL;
+		dev_err(chan2dev(chan), "%s: buffer is too big\n",
+			__func__);
+		return NULL;
 	}
 
-	atdma_sg->lli = dma_pool_alloc(atdma->lli_pool, GFP_NOWAIT,
-				       &atdma_sg->lli_phys);
-	if (!atdma_sg->lli)
-		return -ENOMEM;
-	lli = atdma_sg->lli;
+	desc = atc_desc_get(atchan);
+	if (!desc) {
+		dev_err(chan2dev(chan), "%s: can't get a descriptor\n",
+			__func__);
+		return NULL;
+	}
 
-	lli->saddr = psrc;
-	lli->daddr = pdst;
-	lli->ctrla = ctrla | xfer_count;
-	lli->ctrlb = ctrlb;
+	desc->lli.saddr = psrc;
+	desc->lli.daddr = pdst;
+	desc->lli.ctrla = ctrla | xfer_count;
+	desc->lli.ctrlb = ctrlb;
 
-	atdma_sg->len = len;
+	desc->txd.cookie = 0;
+	desc->len = len;
 
-	return 0;
+	return desc;
 }
 
 /**
@@ -1072,13 +938,10 @@ static struct dma_async_tx_descriptor *
 atc_prep_dma_memset(struct dma_chan *chan, dma_addr_t dest, int value,
 		    size_t len, unsigned long flags)
 {
-	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct at_dma		*atdma = to_at_dma(chan->device);
 	struct at_desc		*desc;
 	void __iomem		*vaddr;
 	dma_addr_t		paddr;
-	char			fill_pattern;
-	int			ret;
 
 	dev_vdbg(chan2dev(chan), "%s: d%pad v0x%x l0x%zx f0x%lx\n", __func__,
 		&dest, value, len, flags);
@@ -1100,37 +963,29 @@ atc_prep_dma_memset(struct dma_chan *cha
 			__func__);
 		return NULL;
 	}
+	*(u32*)vaddr = value;
 
-	/* Only the first byte of value is to be used according to dmaengine */
-	fill_pattern = (char)value;
-
-	*(u32*)vaddr = (fill_pattern << 24) |
-		       (fill_pattern << 16) |
-		       (fill_pattern << 8) |
-		       fill_pattern;
-
-	desc = kzalloc(struct_size(desc, sg, 1), GFP_ATOMIC);
-	if (!desc)
+	desc = atc_create_memset_desc(chan, paddr, dest, len);
+	if (!desc) {
+		dev_err(chan2dev(chan), "%s: couldn't get a descriptor\n",
+			__func__);
 		goto err_free_buffer;
-	desc->sglen = 1;
-
-	ret = atdma_create_memset_lli(chan, desc->sg, paddr, dest, len);
-	if (ret)
-		goto err_free_desc;
+	}
 
 	desc->memset_paddr = paddr;
 	desc->memset_vaddr = vaddr;
 	desc->memset_buffer = true;
 
+	desc->txd.cookie = -EBUSY;
 	desc->total_len = len;
 
 	/* set end-of-link on the descriptor */
-	set_lli_eol(desc, 0);
+	set_desc_eol(desc);
 
-	return vchan_tx_prep(&atchan->vc, &desc->vd, flags);
+	desc->txd.flags = flags;
+
+	return &desc->txd;
 
-err_free_desc:
-	kfree(desc);
 err_free_buffer:
 	dma_pool_free(atdma->memset_pool, vaddr, paddr);
 	return NULL;
@@ -1144,13 +999,12 @@ atc_prep_dma_memset_sg(struct dma_chan *
 {
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct at_dma		*atdma = to_at_dma(chan->device);
-	struct at_desc		*desc;
+	struct at_desc		*desc = NULL, *first = NULL, *prev = NULL;
 	struct scatterlist	*sg;
 	void __iomem		*vaddr;
 	dma_addr_t		paddr;
 	size_t			total_len = 0;
 	int			i;
-	int			ret;
 
 	dev_vdbg(chan2dev(chan), "%s: v0x%x l0x%zx f0x%lx\n", __func__,
 		 value, sg_len, flags);
@@ -1169,11 +1023,6 @@ atc_prep_dma_memset_sg(struct dma_chan *
 	}
 	*(u32*)vaddr = value;
 
-	desc = kzalloc(struct_size(desc, sg, sg_len), GFP_ATOMIC);
-	if (!desc)
-		goto err_free_dma_buf;
-	desc->sglen = sg_len;
-
 	for_each_sg(sgl, sg, sg_len, i) {
 		dma_addr_t dest = sg_dma_address(sg);
 		size_t len = sg_dma_len(sg);
@@ -1184,33 +1033,38 @@ atc_prep_dma_memset_sg(struct dma_chan *
 		if (!is_dma_fill_aligned(chan->device, dest, 0, len)) {
 			dev_err(chan2dev(chan), "%s: buffer is not aligned\n",
 				__func__);
-			goto err_free_desc;
+			goto err_put_desc;
 		}
 
-		ret = atdma_create_memset_lli(chan, &desc->sg[i], paddr, dest,
-					      len);
-		if (ret)
-			goto err_free_desc;
+		desc = atc_create_memset_desc(chan, paddr, dest, len);
+		if (!desc)
+			goto err_put_desc;
+
+		atc_desc_chain(&first, &prev, desc);
 
-		atdma_lli_chain(desc, i);
 		total_len += len;
 	}
 
+	/*
+	 * Only set the buffer pointers on the last descriptor to
+	 * avoid free'ing while we have our transfer still going
+	 */
 	desc->memset_paddr = paddr;
 	desc->memset_vaddr = vaddr;
 	desc->memset_buffer = true;
 
-	desc->total_len = total_len;
+	first->txd.cookie = -EBUSY;
+	first->total_len = total_len;
 
 	/* set end-of-link on the descriptor */
-	set_lli_eol(desc, i - 1);
+	set_desc_eol(desc);
 
-	return vchan_tx_prep(&atchan->vc, &desc->vd, flags);
+	first->txd.flags = flags;
 
-err_free_desc:
-	atdma_desc_free(&desc->vd);
-err_free_dma_buf:
-	dma_pool_free(atdma->memset_pool, vaddr, paddr);
+	return &first->txd;
+
+err_put_desc:
+	atc_desc_put(atchan, first);
 	return NULL;
 }
 
@@ -1228,11 +1082,11 @@ atc_prep_slave_sg(struct dma_chan *chan,
 		unsigned int sg_len, enum dma_transfer_direction direction,
 		unsigned long flags, void *context)
 {
-	struct at_dma		*atdma = to_at_dma(chan->device);
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct at_dma_slave	*atslave = chan->private;
 	struct dma_slave_config	*sconfig = &atchan->dma_sconfig;
-	struct at_desc		*desc;
+	struct at_desc		*first = NULL;
+	struct at_desc		*prev = NULL;
 	u32			ctrla;
 	u32			ctrlb;
 	dma_addr_t		reg;
@@ -1252,38 +1106,27 @@ atc_prep_slave_sg(struct dma_chan *chan,
 		return NULL;
 	}
 
-	desc = kzalloc(struct_size(desc, sg, sg_len), GFP_ATOMIC);
-	if (!desc)
-		return NULL;
-	desc->sglen = sg_len;
-
-	ctrla = FIELD_PREP(ATC_SCSIZE, sconfig->src_maxburst) |
-		FIELD_PREP(ATC_DCSIZE, sconfig->dst_maxburst);
+	ctrla =   ATC_SCSIZE(sconfig->src_maxburst)
+		| ATC_DCSIZE(sconfig->dst_maxburst);
 	ctrlb = ATC_IEN;
 
 	switch (direction) {
 	case DMA_MEM_TO_DEV:
 		reg_width = convert_buswidth(sconfig->dst_addr_width);
-		ctrla |= FIELD_PREP(ATC_DST_WIDTH, reg_width);
-		ctrlb |= FIELD_PREP(ATC_DST_ADDR_MODE,
-				    ATC_DST_ADDR_MODE_FIXED) |
-			 FIELD_PREP(ATC_SRC_ADDR_MODE, ATC_SRC_ADDR_MODE_INCR) |
-			 FIELD_PREP(ATC_FC, ATC_FC_MEM2PER) |
-			 FIELD_PREP(ATC_SIF, atchan->mem_if) |
-			 FIELD_PREP(ATC_DIF, atchan->per_if);
+		ctrla |=  ATC_DST_WIDTH(reg_width);
+		ctrlb |=  ATC_DST_ADDR_MODE_FIXED
+			| ATC_SRC_ADDR_MODE_INCR
+			| ATC_FC_MEM2PER
+			| ATC_SIF(atchan->mem_if) | ATC_DIF(atchan->per_if);
 		reg = sconfig->dst_addr;
 		for_each_sg(sgl, sg, sg_len, i) {
-			struct atdma_sg *atdma_sg = &desc->sg[i];
-			struct at_lli *lli;
+			struct at_desc	*desc;
 			u32		len;
 			u32		mem;
 
-			atdma_sg->lli = dma_pool_alloc(atdma->lli_pool,
-						       GFP_NOWAIT,
-						       &atdma_sg->lli_phys);
-			if (!atdma_sg->lli)
+			desc = atc_desc_get(atchan);
+			if (!desc)
 				goto err_desc_get;
-			lli = atdma_sg->lli;
 
 			mem = sg_dma_address(sg);
 			len = sg_dma_len(sg);
@@ -1296,43 +1139,35 @@ atc_prep_slave_sg(struct dma_chan *chan,
 			if (unlikely(mem & 3 || len & 3))
 				mem_width = 0;
 
-			lli->saddr = mem;
-			lli->daddr = reg;
-			lli->ctrla = ctrla |
-				     FIELD_PREP(ATC_SRC_WIDTH, mem_width) |
-				     len >> mem_width;
-			lli->ctrlb = ctrlb;
+			desc->lli.saddr = mem;
+			desc->lli.daddr = reg;
+			desc->lli.ctrla = ctrla
+					| ATC_SRC_WIDTH(mem_width)
+					| len >> mem_width;
+			desc->lli.ctrlb = ctrlb;
+			desc->len = len;
 
-			atdma_sg->len = len;
+			atc_desc_chain(&first, &prev, desc);
 			total_len += len;
-
-			desc->sg[i].len = len;
-			atdma_lli_chain(desc, i);
 		}
 		break;
 	case DMA_DEV_TO_MEM:
 		reg_width = convert_buswidth(sconfig->src_addr_width);
-		ctrla |= FIELD_PREP(ATC_SRC_WIDTH, reg_width);
-		ctrlb |= FIELD_PREP(ATC_DST_ADDR_MODE, ATC_DST_ADDR_MODE_INCR) |
-			 FIELD_PREP(ATC_SRC_ADDR_MODE,
-				    ATC_SRC_ADDR_MODE_FIXED) |
-			 FIELD_PREP(ATC_FC, ATC_FC_PER2MEM) |
-			 FIELD_PREP(ATC_SIF, atchan->per_if) |
-			 FIELD_PREP(ATC_DIF, atchan->mem_if);
+		ctrla |=  ATC_SRC_WIDTH(reg_width);
+		ctrlb |=  ATC_DST_ADDR_MODE_INCR
+			| ATC_SRC_ADDR_MODE_FIXED
+			| ATC_FC_PER2MEM
+			| ATC_SIF(atchan->per_if) | ATC_DIF(atchan->mem_if);
 
 		reg = sconfig->src_addr;
 		for_each_sg(sgl, sg, sg_len, i) {
-			struct atdma_sg *atdma_sg = &desc->sg[i];
-			struct at_lli *lli;
+			struct at_desc	*desc;
 			u32		len;
 			u32		mem;
 
-			atdma_sg->lli = dma_pool_alloc(atdma->lli_pool,
-						       GFP_NOWAIT,
-						       &atdma_sg->lli_phys);
-			if (!atdma_sg->lli)
+			desc = atc_desc_get(atchan);
+			if (!desc)
 				goto err_desc_get;
-			lli = atdma_sg->lli;
 
 			mem = sg_dma_address(sg);
 			len = sg_dma_len(sg);
@@ -1345,17 +1180,16 @@ atc_prep_slave_sg(struct dma_chan *chan,
 			if (unlikely(mem & 3 || len & 3))
 				mem_width = 0;
 
-			lli->saddr = reg;
-			lli->daddr = mem;
-			lli->ctrla = ctrla |
-				     FIELD_PREP(ATC_DST_WIDTH, mem_width) |
-				     len >> reg_width;
-			lli->ctrlb = ctrlb;
+			desc->lli.saddr = reg;
+			desc->lli.daddr = mem;
+			desc->lli.ctrla = ctrla
+					| ATC_DST_WIDTH(mem_width)
+					| len >> reg_width;
+			desc->lli.ctrlb = ctrlb;
+			desc->len = len;
 
-			desc->sg[i].len = len;
+			atc_desc_chain(&first, &prev, desc);
 			total_len += len;
-
-			atdma_lli_chain(desc, i);
 		}
 		break;
 	default:
@@ -1363,16 +1197,21 @@ atc_prep_slave_sg(struct dma_chan *chan,
 	}
 
 	/* set end-of-link to the last link descriptor of list*/
-	set_lli_eol(desc, i - 1);
+	set_desc_eol(prev);
+
+	/* First descriptor of the chain embedds additional information */
+	first->txd.cookie = -EBUSY;
+	first->total_len = total_len;
 
-	desc->total_len = total_len;
+	/* first link descriptor of list is responsible of flags */
+	first->txd.flags = flags; /* client is in control of this ack */
 
-	return vchan_tx_prep(&atchan->vc, &desc->vd, flags);
+	return &first->txd;
 
 err_desc_get:
 	dev_err(chan2dev(chan), "not enough descriptors available\n");
 err:
-	atdma_desc_free(&desc->vd);
+	atc_desc_put(atchan, first);
 	return NULL;
 }
 
@@ -1402,59 +1241,50 @@ err_out:
  */
 static int
 atc_dma_cyclic_fill_desc(struct dma_chan *chan, struct at_desc *desc,
-		unsigned int i, dma_addr_t buf_addr,
+		unsigned int period_index, dma_addr_t buf_addr,
 		unsigned int reg_width, size_t period_len,
 		enum dma_transfer_direction direction)
 {
-	struct at_dma		*atdma = to_at_dma(chan->device);
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct dma_slave_config	*sconfig = &atchan->dma_sconfig;
-	struct atdma_sg		*atdma_sg = &desc->sg[i];
-	struct at_lli		*lli;
+	u32			ctrla;
 
-	atdma_sg->lli = dma_pool_alloc(atdma->lli_pool, GFP_ATOMIC,
-				       &atdma_sg->lli_phys);
-	if (!atdma_sg->lli)
-		return -ENOMEM;
-	lli = atdma_sg->lli;
+	/* prepare common CRTLA value */
+	ctrla =   ATC_SCSIZE(sconfig->src_maxburst)
+		| ATC_DCSIZE(sconfig->dst_maxburst)
+		| ATC_DST_WIDTH(reg_width)
+		| ATC_SRC_WIDTH(reg_width)
+		| period_len >> reg_width;
 
 	switch (direction) {
 	case DMA_MEM_TO_DEV:
-		lli->saddr = buf_addr + (period_len * i);
-		lli->daddr = sconfig->dst_addr;
-		lli->ctrlb = FIELD_PREP(ATC_DST_ADDR_MODE,
-					ATC_DST_ADDR_MODE_FIXED) |
-			     FIELD_PREP(ATC_SRC_ADDR_MODE,
-					ATC_SRC_ADDR_MODE_INCR) |
-			     FIELD_PREP(ATC_FC, ATC_FC_MEM2PER) |
-			     FIELD_PREP(ATC_SIF, atchan->mem_if) |
-			     FIELD_PREP(ATC_DIF, atchan->per_if);
-
+		desc->lli.saddr = buf_addr + (period_len * period_index);
+		desc->lli.daddr = sconfig->dst_addr;
+		desc->lli.ctrla = ctrla;
+		desc->lli.ctrlb = ATC_DST_ADDR_MODE_FIXED
+				| ATC_SRC_ADDR_MODE_INCR
+				| ATC_FC_MEM2PER
+				| ATC_SIF(atchan->mem_if)
+				| ATC_DIF(atchan->per_if);
+		desc->len = period_len;
 		break;
 
 	case DMA_DEV_TO_MEM:
-		lli->saddr = sconfig->src_addr;
-		lli->daddr = buf_addr + (period_len * i);
-		lli->ctrlb = FIELD_PREP(ATC_DST_ADDR_MODE,
-					ATC_DST_ADDR_MODE_INCR) |
-			     FIELD_PREP(ATC_SRC_ADDR_MODE,
-					ATC_SRC_ADDR_MODE_FIXED) |
-			     FIELD_PREP(ATC_FC, ATC_FC_PER2MEM) |
-			     FIELD_PREP(ATC_SIF, atchan->per_if) |
-			     FIELD_PREP(ATC_DIF, atchan->mem_if);
+		desc->lli.saddr = sconfig->src_addr;
+		desc->lli.daddr = buf_addr + (period_len * period_index);
+		desc->lli.ctrla = ctrla;
+		desc->lli.ctrlb = ATC_DST_ADDR_MODE_INCR
+				| ATC_SRC_ADDR_MODE_FIXED
+				| ATC_FC_PER2MEM
+				| ATC_SIF(atchan->per_if)
+				| ATC_DIF(atchan->mem_if);
+		desc->len = period_len;
 		break;
 
 	default:
 		return -EINVAL;
 	}
 
-	lli->ctrla = FIELD_PREP(ATC_SCSIZE, sconfig->src_maxburst) |
-		     FIELD_PREP(ATC_DCSIZE, sconfig->dst_maxburst) |
-		     FIELD_PREP(ATC_DST_WIDTH, reg_width) |
-		     FIELD_PREP(ATC_SRC_WIDTH, reg_width) |
-		     period_len >> reg_width;
-	desc->sg[i].len = period_len;
-
 	return 0;
 }
 
@@ -1475,7 +1305,8 @@ atc_prep_dma_cyclic(struct dma_chan *cha
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct at_dma_slave	*atslave = chan->private;
 	struct dma_slave_config	*sconfig = &atchan->dma_sconfig;
-	struct at_desc		*desc;
+	struct at_desc		*first = NULL;
+	struct at_desc		*prev = NULL;
 	unsigned long		was_cyclic;
 	unsigned int		reg_width;
 	unsigned int		periods = buf_len / period_len;
@@ -1509,26 +1340,33 @@ atc_prep_dma_cyclic(struct dma_chan *cha
 	if (atc_dma_cyclic_check_values(reg_width, buf_addr, period_len))
 		goto err_out;
 
-	desc = kzalloc(struct_size(desc, sg, periods), GFP_ATOMIC);
-	if (!desc)
-		goto err_out;
-	desc->sglen = periods;
-
 	/* build cyclic linked list */
 	for (i = 0; i < periods; i++) {
+		struct at_desc	*desc;
+
+		desc = atc_desc_get(atchan);
+		if (!desc)
+			goto err_desc_get;
+
 		if (atc_dma_cyclic_fill_desc(chan, desc, i, buf_addr,
 					     reg_width, period_len, direction))
-			goto err_fill_desc;
-		atdma_lli_chain(desc, i);
+			goto err_desc_get;
+
+		atc_desc_chain(&first, &prev, desc);
 	}
-	desc->total_len = buf_len;
+
 	/* lets make a cyclic list */
-	desc->sg[i - 1].lli->dscr = desc->sg[0].lli_phys;
+	prev->lli.dscr = first->txd.phys;
+
+	/* First descriptor of the chain embedds additional information */
+	first->txd.cookie = -EBUSY;
+	first->total_len = buf_len;
 
-	return vchan_tx_prep(&atchan->vc, &desc->vd, flags);
+	return &first->txd;
 
-err_fill_desc:
-	atdma_desc_free(&desc->vd);
+err_desc_get:
+	dev_err(chan2dev(chan), "not enough descriptors available\n");
+	atc_desc_put(atchan, first);
 err_out:
 	clear_bit(ATC_IS_CYCLIC, &atchan->status);
 	return NULL;
@@ -1557,17 +1395,17 @@ static int atc_pause(struct dma_chan *ch
 {
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct at_dma		*atdma = to_at_dma(chan->device);
-	int			chan_id = atchan->vc.chan.chan_id;
+	int			chan_id = atchan->chan_common.chan_id;
 	unsigned long		flags;
 
 	dev_vdbg(chan2dev(chan), "%s\n", __func__);
 
-	spin_lock_irqsave(&atchan->vc.lock, flags);
+	spin_lock_irqsave(&atchan->lock, flags);
 
 	dma_writel(atdma, CHER, AT_DMA_SUSP(chan_id));
 	set_bit(ATC_IS_PAUSED, &atchan->status);
 
-	spin_unlock_irqrestore(&atchan->vc.lock, flags);
+	spin_unlock_irqrestore(&atchan->lock, flags);
 
 	return 0;
 }
@@ -1576,7 +1414,7 @@ static int atc_resume(struct dma_chan *c
 {
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct at_dma		*atdma = to_at_dma(chan->device);
-	int			chan_id = atchan->vc.chan.chan_id;
+	int			chan_id = atchan->chan_common.chan_id;
 	unsigned long		flags;
 
 	dev_vdbg(chan2dev(chan), "%s\n", __func__);
@@ -1584,12 +1422,12 @@ static int atc_resume(struct dma_chan *c
 	if (!atc_chan_is_paused(atchan))
 		return 0;
 
-	spin_lock_irqsave(&atchan->vc.lock, flags);
+	spin_lock_irqsave(&atchan->lock, flags);
 
 	dma_writel(atdma, CHDR, AT_DMA_RES(chan_id));
 	clear_bit(ATC_IS_PAUSED, &atchan->status);
 
-	spin_unlock_irqrestore(&atchan->vc.lock, flags);
+	spin_unlock_irqrestore(&atchan->lock, flags);
 
 	return 0;
 }
@@ -1598,7 +1436,8 @@ static int atc_terminate_all(struct dma_
 {
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct at_dma		*atdma = to_at_dma(chan->device);
-	int			chan_id = atchan->vc.chan.chan_id;
+	int			chan_id = atchan->chan_common.chan_id;
+	struct at_desc		*desc, *_desc;
 	unsigned long		flags;
 
 	LIST_HEAD(list);
@@ -1611,7 +1450,7 @@ static int atc_terminate_all(struct dma_
 	 * channel. We still have to poll the channel enable bit due
 	 * to AHB/HSB limitations.
 	 */
-	spin_lock_irqsave(&atchan->vc.lock, flags);
+	spin_lock_irqsave(&atchan->lock, flags);
 
 	/* disabling channel: must also remove suspend state */
 	dma_writel(atdma, CHDR, AT_DMA_RES(chan_id) | atchan->mask);
@@ -1620,21 +1459,20 @@ static int atc_terminate_all(struct dma_
 	while (dma_readl(atdma, CHSR) & atchan->mask)
 		cpu_relax();
 
-	if (atchan->desc) {
-		vchan_terminate_vdesc(&atchan->desc->vd);
-		atchan->desc = NULL;
-	}
-
-	vchan_get_all_descriptors(&atchan->vc, &list);
+	/* active_list entries will end up before queued entries */
+	list_splice_init(&atchan->queue, &list);
+	list_splice_init(&atchan->active_list, &list);
+
+	spin_unlock_irqrestore(&atchan->lock, flags);
+
+	/* Flush all pending and queued descriptors */
+	list_for_each_entry_safe(desc, _desc, &list, desc_node)
+		atc_chain_complete(atchan, desc);
 
 	clear_bit(ATC_IS_PAUSED, &atchan->status);
 	/* if channel dedicated to cyclic operations, free it */
 	clear_bit(ATC_IS_CYCLIC, &atchan->status);
 
-	spin_unlock_irqrestore(&atchan->vc.lock, flags);
-
-	vchan_dma_desc_free_list(&atchan->vc, &list);
-
 	return 0;
 }
 
@@ -1655,43 +1493,54 @@ atc_tx_status(struct dma_chan *chan,
 {
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	unsigned long		flags;
-	enum dma_status		dma_status;
-	u32 residue;
-	int ret;
+	enum dma_status		ret;
+	int bytes = 0;
+
+	ret = dma_cookie_status(chan, cookie, txstate);
+	if (ret == DMA_COMPLETE)
+		return ret;
+	/*
+	 * There's no point calculating the residue if there's
+	 * no txstate to store the value.
+	 */
+	if (!txstate)
+		return DMA_ERROR;
 
-	dma_status = dma_cookie_status(chan, cookie, txstate);
-	if (dma_status == DMA_COMPLETE || !txstate)
-		return dma_status;
+	spin_lock_irqsave(&atchan->lock, flags);
 
-	spin_lock_irqsave(&atchan->vc.lock, flags);
 	/*  Get number of bytes left in the active transactions */
-	ret = atc_get_residue(chan, cookie, &residue);
-	spin_unlock_irqrestore(&atchan->vc.lock, flags);
+	bytes = atc_get_bytes_left(chan, cookie);
+
+	spin_unlock_irqrestore(&atchan->lock, flags);
 
-	if (unlikely(ret < 0)) {
+	if (unlikely(bytes < 0)) {
 		dev_vdbg(chan2dev(chan), "get residual bytes error\n");
 		return DMA_ERROR;
 	} else {
-		dma_set_residue(txstate, residue);
+		dma_set_residue(txstate, bytes);
 	}
 
-	dev_vdbg(chan2dev(chan), "tx_status %d: cookie = %d residue = %u\n",
-		 dma_status, cookie, residue);
+	dev_vdbg(chan2dev(chan), "tx_status %d: cookie = %d residue = %d\n",
+		 ret, cookie, bytes);
 
-	return dma_status;
+	return ret;
 }
 
+/**
+ * atc_issue_pending - try to finish work
+ * @chan: target DMA channel
+ */
 static void atc_issue_pending(struct dma_chan *chan)
 {
-	struct at_dma_chan *atchan = to_at_dma_chan(chan);
-	unsigned long flags;
+	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 
-	spin_lock_irqsave(&atchan->vc.lock, flags);
-	if (vchan_issue_pending(&atchan->vc) && !atchan->desc) {
-		if (!(atc_chan_is_enabled(atchan)))
-			atc_dostart(atchan);
-	}
-	spin_unlock_irqrestore(&atchan->vc.lock, flags);
+	dev_vdbg(chan2dev(chan), "issue_pending\n");
+
+	/* Not needed for cyclic transfers */
+	if (atc_chan_is_cyclic(atchan))
+		return;
+
+	atc_advance_work(atchan);
 }
 
 /**
@@ -1704,7 +1553,9 @@ static int atc_alloc_chan_resources(stru
 {
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct at_dma		*atdma = to_at_dma(chan->device);
+	struct at_desc		*desc;
 	struct at_dma_slave	*atslave;
+	int			i;
 	u32			cfg;
 
 	dev_vdbg(chan2dev(chan), "alloc_chan_resources\n");
@@ -1715,6 +1566,11 @@ static int atc_alloc_chan_resources(stru
 		return -EIO;
 	}
 
+	if (!list_empty(&atchan->free_list)) {
+		dev_dbg(chan2dev(chan), "can't allocate channel resources (channel not freed from a previous use)\n");
+		return -EIO;
+	}
+
 	cfg = ATC_DEFAULT_CFG;
 
 	atslave = chan->private;
@@ -1723,17 +1579,33 @@ static int atc_alloc_chan_resources(stru
 		 * We need controller-specific data to set up slave
 		 * transfers.
 		 */
-		BUG_ON(!atslave->dma_dev || atslave->dma_dev != atdma->dma_device.dev);
+		BUG_ON(!atslave->dma_dev || atslave->dma_dev != atdma->dma_common.dev);
 
 		/* if cfg configuration specified take it instead of default */
 		if (atslave->cfg)
 			cfg = atslave->cfg;
 	}
 
+	/* Allocate initial pool of descriptors */
+	for (i = 0; i < init_nr_desc_per_channel; i++) {
+		desc = atc_alloc_descriptor(chan, GFP_KERNEL);
+		if (!desc) {
+			dev_err(atdma->dma_common.dev,
+				"Only %d initial descriptors\n", i);
+			break;
+		}
+		list_add_tail(&desc->desc_node, &atchan->free_list);
+	}
+
+	dma_cookie_init(chan);
+
 	/* channel parameters */
 	channel_writel(atchan, CFG, cfg);
 
-	return 0;
+	dev_dbg(chan2dev(chan),
+		"alloc_chan_resources: allocated %d descriptors\n", i);
+
+	return i;
 }
 
 /**
@@ -1743,10 +1615,22 @@ static int atc_alloc_chan_resources(stru
 static void atc_free_chan_resources(struct dma_chan *chan)
 {
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
+	struct at_dma		*atdma = to_at_dma(chan->device);
+	struct at_desc		*desc, *_desc;
+	LIST_HEAD(list);
 
+	/* ASSERT:  channel is idle */
+	BUG_ON(!list_empty(&atchan->active_list));
+	BUG_ON(!list_empty(&atchan->queue));
 	BUG_ON(atc_chan_is_enabled(atchan));
 
-	vchan_free_chan_resources(to_virt_chan(chan));
+	list_for_each_entry_safe(desc, _desc, &atchan->free_list, desc_node) {
+		dev_vdbg(chan2dev(chan), "  freeing descriptor %p\n", desc);
+		list_del(&desc->desc_node);
+		/* free link descriptor */
+		dma_pool_free(atdma->dma_desc_pool, desc, desc->txd.phys);
+	}
+	list_splice_init(&atchan->free_list, &list);
 	atchan->status = 0;
 
 	/*
@@ -1797,13 +1681,14 @@ static struct dma_chan *at_dma_xlate(str
 		return NULL;
 	}
 
-	atslave->cfg = ATC_DST_H2SEL | ATC_SRC_H2SEL;
+	atslave->cfg = ATC_DST_H2SEL_HW | ATC_SRC_H2SEL_HW;
 	/*
 	 * We can fill both SRC_PER and DST_PER, one of these fields will be
 	 * ignored depending on DMA transfer direction.
 	 */
 	per_id = dma_spec->args[1] & AT91_DMA_CFG_PER_ID_MASK;
-	atslave->cfg |= ATC_DST_PER_ID(per_id) |  ATC_SRC_PER_ID(per_id);
+	atslave->cfg |= ATC_DST_PER_MSB(per_id) | ATC_DST_PER(per_id)
+		     | ATC_SRC_PER_MSB(per_id) | ATC_SRC_PER(per_id);
 	/*
 	 * We have to translate the value we get from the device tree since
 	 * the half FIFO configuration value had to be 0 to keep backward
@@ -1811,16 +1696,14 @@ static struct dma_chan *at_dma_xlate(str
 	 */
 	switch (dma_spec->args[1] & AT91_DMA_CFG_FIFOCFG_MASK) {
 	case AT91_DMA_CFG_FIFOCFG_ALAP:
-		atslave->cfg |= FIELD_PREP(ATC_FIFOCFG,
-					   ATC_FIFOCFG_LARGESTBURST);
+		atslave->cfg |= ATC_FIFOCFG_LARGESTBURST;
 		break;
 	case AT91_DMA_CFG_FIFOCFG_ASAP:
-		atslave->cfg |= FIELD_PREP(ATC_FIFOCFG,
-					   ATC_FIFOCFG_ENOUGHSPACE);
+		atslave->cfg |= ATC_FIFOCFG_ENOUGHSPACE;
 		break;
 	case AT91_DMA_CFG_FIFOCFG_HALF:
 	default:
-		atslave->cfg |= FIELD_PREP(ATC_FIFOCFG, ATC_FIFOCFG_HALFFIFO);
+		atslave->cfg |= ATC_FIFOCFG_HALFFIFO;
 	}
 	atslave->dma_dev = &dmac_pdev->dev;
 
@@ -1915,7 +1798,9 @@ static void at_dma_off(struct at_dma *at
 
 static int __init at_dma_probe(struct platform_device *pdev)
 {
+	struct resource		*io;
 	struct at_dma		*atdma;
+	size_t			size;
 	int			irq;
 	int			err;
 	int			i;
@@ -1935,47 +1820,60 @@ static int __init at_dma_probe(struct pl
 	if (!plat_dat)
 		return -ENODEV;
 
-	atdma = devm_kzalloc(&pdev->dev,
-			     struct_size(atdma, chan, plat_dat->nr_channels),
-			     GFP_KERNEL);
-	if (!atdma)
-		return -ENOMEM;
-
-	atdma->regs = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(atdma->regs))
-		return PTR_ERR(atdma->regs);
+	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!io)
+		return -EINVAL;
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return irq;
-	err = devm_request_irq(&pdev->dev, irq, at_dma_interrupt, 0,
-			       dev_name(&pdev->dev), atdma);
-	if (err)
-		return err;
+
+	size = sizeof(struct at_dma);
+	size += plat_dat->nr_channels * sizeof(struct at_dma_chan);
+	atdma = kzalloc(size, GFP_KERNEL);
+	if (!atdma)
+		return -ENOMEM;
 
 	/* discover transaction capabilities */
-	atdma->dma_device.cap_mask = plat_dat->cap_mask;
+	atdma->dma_common.cap_mask = plat_dat->cap_mask;
 	atdma->all_chan_mask = (1 << plat_dat->nr_channels) - 1;
 
-	atdma->clk = devm_clk_get(&pdev->dev, "dma_clk");
-	if (IS_ERR(atdma->clk))
-		return PTR_ERR(atdma->clk);
+	size = resource_size(io);
+	if (!request_mem_region(io->start, size, pdev->dev.driver->name)) {
+		err = -EBUSY;
+		goto err_kfree;
+	}
 
+	atdma->regs = ioremap(io->start, size);
+	if (!atdma->regs) {
+		err = -ENOMEM;
+		goto err_release_r;
+	}
+
+	atdma->clk = clk_get(&pdev->dev, "dma_clk");
+	if (IS_ERR(atdma->clk)) {
+		err = PTR_ERR(atdma->clk);
+		goto err_clk;
+	}
 	err = clk_prepare_enable(atdma->clk);
 	if (err)
-		return err;
+		goto err_clk_prepare;
 
 	/* force dma off, just in case */
 	at_dma_off(atdma);
 
+	err = request_irq(irq, at_dma_interrupt, 0, "at_hdmac", atdma);
+	if (err)
+		goto err_irq;
+
 	platform_set_drvdata(pdev, atdma);
 
 	/* create a pool of consistent memory blocks for hardware descriptors */
-	atdma->lli_pool = dma_pool_create("at_hdmac_lli_pool",
-					  &pdev->dev, sizeof(struct at_lli),
-					  4 /* word alignment */, 0);
-	if (!atdma->lli_pool) {
-		dev_err(&pdev->dev, "Unable to allocate DMA LLI descriptor pool\n");
+	atdma->dma_desc_pool = dma_pool_create("at_hdmac_desc_pool",
+			&pdev->dev, sizeof(struct at_desc),
+			4 /* word alignment */, 0);
+	if (!atdma->dma_desc_pool) {
+		dev_err(&pdev->dev, "No memory for descriptors dma pool\n");
 		err = -ENOMEM;
 		goto err_desc_pool_create;
 	}
@@ -1994,70 +1892,73 @@ static int __init at_dma_probe(struct pl
 		cpu_relax();
 
 	/* initialize channels related values */
-	INIT_LIST_HEAD(&atdma->dma_device.channels);
+	INIT_LIST_HEAD(&atdma->dma_common.channels);
 	for (i = 0; i < plat_dat->nr_channels; i++) {
 		struct at_dma_chan	*atchan = &atdma->chan[i];
 
 		atchan->mem_if = AT_DMA_MEM_IF;
 		atchan->per_if = AT_DMA_PER_IF;
+		atchan->chan_common.device = &atdma->dma_common;
+		dma_cookie_init(&atchan->chan_common);
+		list_add_tail(&atchan->chan_common.device_node,
+				&atdma->dma_common.channels);
 
 		atchan->ch_regs = atdma->regs + ch_regs(i);
+		spin_lock_init(&atchan->lock);
 		atchan->mask = 1 << i;
 
-		atchan->atdma = atdma;
-		atchan->vc.desc_free = atdma_desc_free;
-		vchan_init(&atchan->vc, &atdma->dma_device);
+		INIT_LIST_HEAD(&atchan->active_list);
+		INIT_LIST_HEAD(&atchan->queue);
+		INIT_LIST_HEAD(&atchan->free_list);
+
+		tasklet_setup(&atchan->tasklet, atc_tasklet);
 		atc_enable_chan_irq(atdma, i);
 	}
 
 	/* set base routines */
-	atdma->dma_device.device_alloc_chan_resources = atc_alloc_chan_resources;
-	atdma->dma_device.device_free_chan_resources = atc_free_chan_resources;
-	atdma->dma_device.device_tx_status = atc_tx_status;
-	atdma->dma_device.device_issue_pending = atc_issue_pending;
-	atdma->dma_device.dev = &pdev->dev;
+	atdma->dma_common.device_alloc_chan_resources = atc_alloc_chan_resources;
+	atdma->dma_common.device_free_chan_resources = atc_free_chan_resources;
+	atdma->dma_common.device_tx_status = atc_tx_status;
+	atdma->dma_common.device_issue_pending = atc_issue_pending;
+	atdma->dma_common.dev = &pdev->dev;
 
 	/* set prep routines based on capability */
-	if (dma_has_cap(DMA_INTERLEAVE, atdma->dma_device.cap_mask))
-		atdma->dma_device.device_prep_interleaved_dma = atc_prep_dma_interleaved;
+	if (dma_has_cap(DMA_INTERLEAVE, atdma->dma_common.cap_mask))
+		atdma->dma_common.device_prep_interleaved_dma = atc_prep_dma_interleaved;
 
-	if (dma_has_cap(DMA_MEMCPY, atdma->dma_device.cap_mask))
-		atdma->dma_device.device_prep_dma_memcpy = atc_prep_dma_memcpy;
+	if (dma_has_cap(DMA_MEMCPY, atdma->dma_common.cap_mask))
+		atdma->dma_common.device_prep_dma_memcpy = atc_prep_dma_memcpy;
 
-	if (dma_has_cap(DMA_MEMSET, atdma->dma_device.cap_mask)) {
-		atdma->dma_device.device_prep_dma_memset = atc_prep_dma_memset;
-		atdma->dma_device.device_prep_dma_memset_sg = atc_prep_dma_memset_sg;
-		atdma->dma_device.fill_align = DMAENGINE_ALIGN_4_BYTES;
+	if (dma_has_cap(DMA_MEMSET, atdma->dma_common.cap_mask)) {
+		atdma->dma_common.device_prep_dma_memset = atc_prep_dma_memset;
+		atdma->dma_common.device_prep_dma_memset_sg = atc_prep_dma_memset_sg;
+		atdma->dma_common.fill_align = DMAENGINE_ALIGN_4_BYTES;
 	}
 
-	if (dma_has_cap(DMA_SLAVE, atdma->dma_device.cap_mask)) {
-		atdma->dma_device.device_prep_slave_sg = atc_prep_slave_sg;
+	if (dma_has_cap(DMA_SLAVE, atdma->dma_common.cap_mask)) {
+		atdma->dma_common.device_prep_slave_sg = atc_prep_slave_sg;
 		/* controller can do slave DMA: can trigger cyclic transfers */
-		dma_cap_set(DMA_CYCLIC, atdma->dma_device.cap_mask);
-		atdma->dma_device.device_prep_dma_cyclic = atc_prep_dma_cyclic;
-		atdma->dma_device.device_config = atc_config;
-		atdma->dma_device.device_pause = atc_pause;
-		atdma->dma_device.device_resume = atc_resume;
-		atdma->dma_device.device_terminate_all = atc_terminate_all;
-		atdma->dma_device.src_addr_widths = ATC_DMA_BUSWIDTHS;
-		atdma->dma_device.dst_addr_widths = ATC_DMA_BUSWIDTHS;
-		atdma->dma_device.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
-		atdma->dma_device.residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;
+		dma_cap_set(DMA_CYCLIC, atdma->dma_common.cap_mask);
+		atdma->dma_common.device_prep_dma_cyclic = atc_prep_dma_cyclic;
+		atdma->dma_common.device_config = atc_config;
+		atdma->dma_common.device_pause = atc_pause;
+		atdma->dma_common.device_resume = atc_resume;
+		atdma->dma_common.device_terminate_all = atc_terminate_all;
+		atdma->dma_common.src_addr_widths = ATC_DMA_BUSWIDTHS;
+		atdma->dma_common.dst_addr_widths = ATC_DMA_BUSWIDTHS;
+		atdma->dma_common.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
+		atdma->dma_common.residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;
 	}
 
 	dma_writel(atdma, EN, AT_DMA_ENABLE);
 
 	dev_info(&pdev->dev, "Atmel AHB DMA Controller ( %s%s%s), %d channels\n",
-	  dma_has_cap(DMA_MEMCPY, atdma->dma_device.cap_mask) ? "cpy " : "",
-	  dma_has_cap(DMA_MEMSET, atdma->dma_device.cap_mask) ? "set " : "",
-	  dma_has_cap(DMA_SLAVE, atdma->dma_device.cap_mask)  ? "slave " : "",
+	  dma_has_cap(DMA_MEMCPY, atdma->dma_common.cap_mask) ? "cpy " : "",
+	  dma_has_cap(DMA_MEMSET, atdma->dma_common.cap_mask) ? "set " : "",
+	  dma_has_cap(DMA_SLAVE, atdma->dma_common.cap_mask)  ? "slave " : "",
 	  plat_dat->nr_channels);
 
-	err = dma_async_device_register(&atdma->dma_device);
-	if (err) {
-		dev_err(&pdev->dev, "Unable to register: %d.\n", err);
-		goto err_dma_async_device_register;
-	}
+	dma_async_device_register(&atdma->dma_common);
 
 	/*
 	 * Do not return an error if the dmac node is not present in order to
@@ -2076,13 +1977,23 @@ static int __init at_dma_probe(struct pl
 	return 0;
 
 err_of_dma_controller_register:
-	dma_async_device_unregister(&atdma->dma_device);
-err_dma_async_device_register:
+	dma_async_device_unregister(&atdma->dma_common);
 	dma_pool_destroy(atdma->memset_pool);
 err_memset_pool_create:
-	dma_pool_destroy(atdma->lli_pool);
+	dma_pool_destroy(atdma->dma_desc_pool);
 err_desc_pool_create:
+	free_irq(platform_get_irq(pdev, 0), atdma);
+err_irq:
 	clk_disable_unprepare(atdma->clk);
+err_clk_prepare:
+	clk_put(atdma->clk);
+err_clk:
+	iounmap(atdma->regs);
+	atdma->regs = NULL;
+err_release_r:
+	release_mem_region(io->start, size);
+err_kfree:
+	kfree(atdma);
 	return err;
 }
 
@@ -2090,23 +2001,38 @@ static int at_dma_remove(struct platform
 {
 	struct at_dma		*atdma = platform_get_drvdata(pdev);
 	struct dma_chan		*chan, *_chan;
+	struct resource		*io;
 
 	at_dma_off(atdma);
 	if (pdev->dev.of_node)
 		of_dma_controller_free(pdev->dev.of_node);
-	dma_async_device_unregister(&atdma->dma_device);
+	dma_async_device_unregister(&atdma->dma_common);
 
 	dma_pool_destroy(atdma->memset_pool);
-	dma_pool_destroy(atdma->lli_pool);
+	dma_pool_destroy(atdma->dma_desc_pool);
+	free_irq(platform_get_irq(pdev, 0), atdma);
 
-	list_for_each_entry_safe(chan, _chan, &atdma->dma_device.channels,
+	list_for_each_entry_safe(chan, _chan, &atdma->dma_common.channels,
 			device_node) {
+		struct at_dma_chan	*atchan = to_at_dma_chan(chan);
+
 		/* Disable interrupts */
 		atc_disable_chan_irq(atdma, chan->chan_id);
+
+		tasklet_kill(&atchan->tasklet);
 		list_del(&chan->device_node);
 	}
 
 	clk_disable_unprepare(atdma->clk);
+	clk_put(atdma->clk);
+
+	iounmap(atdma->regs);
+	atdma->regs = NULL;
+
+	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(io->start, resource_size(io));
+
+	kfree(atdma);
 
 	return 0;
 }
@@ -2124,7 +2050,7 @@ static int at_dma_prepare(struct device
 	struct at_dma *atdma = dev_get_drvdata(dev);
 	struct dma_chan *chan, *_chan;
 
-	list_for_each_entry_safe(chan, _chan, &atdma->dma_device.channels,
+	list_for_each_entry_safe(chan, _chan, &atdma->dma_common.channels,
 			device_node) {
 		struct at_dma_chan *atchan = to_at_dma_chan(chan);
 		/* wait for transaction completion (except in cyclic case) */
@@ -2136,7 +2062,7 @@ static int at_dma_prepare(struct device
 
 static void atc_suspend_cyclic(struct at_dma_chan *atchan)
 {
-	struct dma_chan	*chan = &atchan->vc.chan;
+	struct dma_chan	*chan = &atchan->chan_common;
 
 	/* Channel should be paused by user
 	 * do it anyway even if it is not done already */
@@ -2159,7 +2085,7 @@ static int at_dma_suspend_noirq(struct d
 	struct dma_chan *chan, *_chan;
 
 	/* preserve data */
-	list_for_each_entry_safe(chan, _chan, &atdma->dma_device.channels,
+	list_for_each_entry_safe(chan, _chan, &atdma->dma_common.channels,
 			device_node) {
 		struct at_dma_chan *atchan = to_at_dma_chan(chan);
 
@@ -2177,7 +2103,7 @@ static int at_dma_suspend_noirq(struct d
 
 static void atc_resume_cyclic(struct at_dma_chan *atchan)
 {
-	struct at_dma	*atdma = to_at_dma(atchan->vc.chan.device);
+	struct at_dma	*atdma = to_at_dma(atchan->chan_common.device);
 
 	/* restore channel status for cyclic descriptors list:
 	 * next descriptor in the cyclic list at the time of suspend */
@@ -2209,7 +2135,7 @@ static int at_dma_resume_noirq(struct de
 
 	/* restore saved data */
 	dma_writel(atdma, EBCIER, atdma->save_imr);
-	list_for_each_entry_safe(chan, _chan, &atdma->dma_device.channels,
+	list_for_each_entry_safe(chan, _chan, &atdma->dma_common.channels,
 			device_node) {
 		struct at_dma_chan *atchan = to_at_dma_chan(chan);
 
@@ -2220,7 +2146,7 @@ static int at_dma_resume_noirq(struct de
 	return 0;
 }
 
-static const struct dev_pm_ops __maybe_unused at_dma_dev_pm_ops = {
+static const struct dev_pm_ops at_dma_dev_pm_ops = {
 	.prepare = at_dma_prepare,
 	.suspend_noirq = at_dma_suspend_noirq,
 	.resume_noirq = at_dma_resume_noirq,
@@ -2232,7 +2158,7 @@ static struct platform_driver at_dma_dri
 	.id_table	= atdma_devtypes,
 	.driver = {
 		.name	= "at_hdmac",
-		.pm	= pm_ptr(&at_dma_dev_pm_ops),
+		.pm	= &at_dma_dev_pm_ops,
 		.of_match_table	= of_match_ptr(atmel_dma_dt_ids),
 	},
 };
@@ -2251,6 +2177,5 @@ module_exit(at_dma_exit);
 
 MODULE_DESCRIPTION("Atmel AHB DMA Controller driver");
 MODULE_AUTHOR("Nicolas Ferre <nicolas.ferre@atmel.com>");
-MODULE_AUTHOR("Tudor Ambarus <tudor.ambarus@microchip.com>");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:at_hdmac");
diff -Napur linux-linux4microchip-2022.10-orig/drivers/dma/at_hdmac_regs.h linux-linux4microchip-2022.10/drivers/dma/at_hdmac_regs.h
--- linux-linux4microchip-2022.10-orig/drivers/dma/at_hdmac_regs.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-linux4microchip-2022.10/drivers/dma/at_hdmac_regs.h	2023-04-26 12:59:50.778634480 -0700
@@ -0,0 +1,478 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Header file for the Atmel AHB DMA Controller driver
+ *
+ * Copyright (C) 2008 Atmel Corporation
+ */
+#ifndef AT_HDMAC_REGS_H
+#define	AT_HDMAC_REGS_H
+
+#define	AT_DMA_MAX_NR_CHANNELS	8
+
+
+#define	AT_DMA_GCFG	0x00	/* Global Configuration Register */
+#define		AT_DMA_IF_BIGEND(i)	(0x1 << (i))	/* AHB-Lite Interface i in Big-endian mode */
+#define		AT_DMA_ARB_CFG	(0x1 << 4)	/* Arbiter mode. */
+#define			AT_DMA_ARB_CFG_FIXED		(0x0 << 4)
+#define			AT_DMA_ARB_CFG_ROUND_ROBIN	(0x1 << 4)
+
+#define	AT_DMA_EN	0x04	/* Controller Enable Register */
+#define		AT_DMA_ENABLE	(0x1 << 0)
+
+#define	AT_DMA_SREQ	0x08	/* Software Single Request Register */
+#define		AT_DMA_SSREQ(x)	(0x1 << ((x) << 1))		/* Request a source single transfer on channel x */
+#define		AT_DMA_DSREQ(x)	(0x1 << (1 + ((x) << 1)))	/* Request a destination single transfer on channel x */
+
+#define	AT_DMA_CREQ	0x0C	/* Software Chunk Transfer Request Register */
+#define		AT_DMA_SCREQ(x)	(0x1 << ((x) << 1))		/* Request a source chunk transfer on channel x */
+#define		AT_DMA_DCREQ(x)	(0x1 << (1 + ((x) << 1)))	/* Request a destination chunk transfer on channel x */
+
+#define	AT_DMA_LAST	0x10	/* Software Last Transfer Flag Register */
+#define		AT_DMA_SLAST(x)	(0x1 << ((x) << 1))		/* This src rq is last tx of buffer on channel x */
+#define		AT_DMA_DLAST(x)	(0x1 << (1 + ((x) << 1)))	/* This dst rq is last tx of buffer on channel x */
+
+#define	AT_DMA_SYNC	0x14	/* Request Synchronization Register */
+#define		AT_DMA_SYR(h)	(0x1 << (h))			/* Synchronize handshake line h */
+
+/* Error, Chained Buffer transfer completed and Buffer transfer completed Interrupt registers */
+#define	AT_DMA_EBCIER	0x18	/* Enable register */
+#define	AT_DMA_EBCIDR	0x1C	/* Disable register */
+#define	AT_DMA_EBCIMR	0x20	/* Mask Register */
+#define	AT_DMA_EBCISR	0x24	/* Status Register */
+#define		AT_DMA_CBTC_OFFSET	8
+#define		AT_DMA_ERR_OFFSET	16
+#define		AT_DMA_BTC(x)	(0x1 << (x))
+#define		AT_DMA_CBTC(x)	(0x1 << (AT_DMA_CBTC_OFFSET + (x)))
+#define		AT_DMA_ERR(x)	(0x1 << (AT_DMA_ERR_OFFSET + (x)))
+
+#define	AT_DMA_CHER	0x28	/* Channel Handler Enable Register */
+#define		AT_DMA_ENA(x)	(0x1 << (x))
+#define		AT_DMA_SUSP(x)	(0x1 << ( 8 + (x)))
+#define		AT_DMA_KEEP(x)	(0x1 << (24 + (x)))
+
+#define	AT_DMA_CHDR	0x2C	/* Channel Handler Disable Register */
+#define		AT_DMA_DIS(x)	(0x1 << (x))
+#define		AT_DMA_RES(x)	(0x1 << ( 8 + (x)))
+
+#define	AT_DMA_CHSR	0x30	/* Channel Handler Status Register */
+#define		AT_DMA_EMPT(x)	(0x1 << (16 + (x)))
+#define		AT_DMA_STAL(x)	(0x1 << (24 + (x)))
+
+
+#define	AT_DMA_CH_REGS_BASE	0x3C	/* Channel registers base address */
+#define	ch_regs(x)	(AT_DMA_CH_REGS_BASE + (x) * 0x28) /* Channel x base addr */
+
+/* Hardware register offset for each channel */
+#define	ATC_SADDR_OFFSET	0x00	/* Source Address Register */
+#define	ATC_DADDR_OFFSET	0x04	/* Destination Address Register */
+#define	ATC_DSCR_OFFSET		0x08	/* Descriptor Address Register */
+#define	ATC_CTRLA_OFFSET	0x0C	/* Control A Register */
+#define	ATC_CTRLB_OFFSET	0x10	/* Control B Register */
+#define	ATC_CFG_OFFSET		0x14	/* Configuration Register */
+#define	ATC_SPIP_OFFSET		0x18	/* Src PIP Configuration Register */
+#define	ATC_DPIP_OFFSET		0x1C	/* Dst PIP Configuration Register */
+
+
+/* Bitfield definitions */
+
+/* Bitfields in DSCR */
+#define	ATC_DSCR_IF(i)		(0x3 & (i))	/* Dsc feched via AHB-Lite Interface i */
+
+/* Bitfields in CTRLA */
+#define	ATC_BTSIZE_MAX		0xFFFFUL	/* Maximum Buffer Transfer Size */
+#define	ATC_BTSIZE(x)		(ATC_BTSIZE_MAX & (x)) /* Buffer Transfer Size */
+#define	ATC_SCSIZE_MASK		(0x7 << 16)	/* Source Chunk Transfer Size */
+#define		ATC_SCSIZE(x)		(ATC_SCSIZE_MASK & ((x) << 16))
+#define		ATC_SCSIZE_1		(0x0 << 16)
+#define		ATC_SCSIZE_4		(0x1 << 16)
+#define		ATC_SCSIZE_8		(0x2 << 16)
+#define		ATC_SCSIZE_16		(0x3 << 16)
+#define		ATC_SCSIZE_32		(0x4 << 16)
+#define		ATC_SCSIZE_64		(0x5 << 16)
+#define		ATC_SCSIZE_128		(0x6 << 16)
+#define		ATC_SCSIZE_256		(0x7 << 16)
+#define	ATC_DCSIZE_MASK		(0x7 << 20)	/* Destination Chunk Transfer Size */
+#define		ATC_DCSIZE(x)		(ATC_DCSIZE_MASK & ((x) << 20))
+#define		ATC_DCSIZE_1		(0x0 << 20)
+#define		ATC_DCSIZE_4		(0x1 << 20)
+#define		ATC_DCSIZE_8		(0x2 << 20)
+#define		ATC_DCSIZE_16		(0x3 << 20)
+#define		ATC_DCSIZE_32		(0x4 << 20)
+#define		ATC_DCSIZE_64		(0x5 << 20)
+#define		ATC_DCSIZE_128		(0x6 << 20)
+#define		ATC_DCSIZE_256		(0x7 << 20)
+#define	ATC_SRC_WIDTH_MASK	(0x3 << 24)	/* Source Single Transfer Size */
+#define		ATC_SRC_WIDTH(x)	((x) << 24)
+#define		ATC_SRC_WIDTH_BYTE	(0x0 << 24)
+#define		ATC_SRC_WIDTH_HALFWORD	(0x1 << 24)
+#define		ATC_SRC_WIDTH_WORD	(0x2 << 24)
+#define		ATC_REG_TO_SRC_WIDTH(r)	(((r) >> 24) & 0x3)
+#define	ATC_DST_WIDTH_MASK	(0x3 << 28)	/* Destination Single Transfer Size */
+#define		ATC_DST_WIDTH(x)	((x) << 28)
+#define		ATC_DST_WIDTH_BYTE	(0x0 << 28)
+#define		ATC_DST_WIDTH_HALFWORD	(0x1 << 28)
+#define		ATC_DST_WIDTH_WORD	(0x2 << 28)
+#define	ATC_DONE		(0x1 << 31)	/* Tx Done (only written back in descriptor) */
+
+/* Bitfields in CTRLB */
+#define	ATC_SIF(i)		(0x3 & (i))	/* Src tx done via AHB-Lite Interface i */
+#define	ATC_DIF(i)		((0x3 & (i)) <<  4)	/* Dst tx done via AHB-Lite Interface i */
+				  /* Specify AHB interfaces */
+#define AT_DMA_MEM_IF		0 /* interface 0 as memory interface */
+#define AT_DMA_PER_IF		1 /* interface 1 as peripheral interface */
+
+#define	ATC_SRC_PIP		(0x1 <<  8)	/* Source Picture-in-Picture enabled */
+#define	ATC_DST_PIP		(0x1 << 12)	/* Destination Picture-in-Picture enabled */
+#define	ATC_SRC_DSCR_DIS	(0x1 << 16)	/* Src Descriptor fetch disable */
+#define	ATC_DST_DSCR_DIS	(0x1 << 20)	/* Dst Descriptor fetch disable */
+#define	ATC_FC_MASK		(0x7 << 21)	/* Choose Flow Controller */
+#define		ATC_FC_MEM2MEM		(0x0 << 21)	/* Mem-to-Mem (DMA) */
+#define		ATC_FC_MEM2PER		(0x1 << 21)	/* Mem-to-Periph (DMA) */
+#define		ATC_FC_PER2MEM		(0x2 << 21)	/* Periph-to-Mem (DMA) */
+#define		ATC_FC_PER2PER		(0x3 << 21)	/* Periph-to-Periph (DMA) */
+#define		ATC_FC_PER2MEM_PER	(0x4 << 21)	/* Periph-to-Mem (Peripheral) */
+#define		ATC_FC_MEM2PER_PER	(0x5 << 21)	/* Mem-to-Periph (Peripheral) */
+#define		ATC_FC_PER2PER_SRCPER	(0x6 << 21)	/* Periph-to-Periph (Src Peripheral) */
+#define		ATC_FC_PER2PER_DSTPER	(0x7 << 21)	/* Periph-to-Periph (Dst Peripheral) */
+#define	ATC_SRC_ADDR_MODE_MASK	(0x3 << 24)
+#define		ATC_SRC_ADDR_MODE_INCR	(0x0 << 24)	/* Incrementing Mode */
+#define		ATC_SRC_ADDR_MODE_DECR	(0x1 << 24)	/* Decrementing Mode */
+#define		ATC_SRC_ADDR_MODE_FIXED	(0x2 << 24)	/* Fixed Mode */
+#define	ATC_DST_ADDR_MODE_MASK	(0x3 << 28)
+#define		ATC_DST_ADDR_MODE_INCR	(0x0 << 28)	/* Incrementing Mode */
+#define		ATC_DST_ADDR_MODE_DECR	(0x1 << 28)	/* Decrementing Mode */
+#define		ATC_DST_ADDR_MODE_FIXED	(0x2 << 28)	/* Fixed Mode */
+#define	ATC_IEN			(0x1 << 30)	/* BTC interrupt enable (active low) */
+#define	ATC_AUTO		(0x1 << 31)	/* Auto multiple buffer tx enable */
+
+/* Bitfields in CFG */
+#define ATC_PER_MSB(h)	((0x30U & (h)) >> 4)	/* Extract most significant bits of a handshaking identifier */
+
+#define	ATC_SRC_PER(h)		(0xFU & (h))	/* Channel src rq associated with periph handshaking ifc h */
+#define	ATC_DST_PER(h)		((0xFU & (h)) <<  4)	/* Channel dst rq associated with periph handshaking ifc h */
+#define	ATC_SRC_REP		(0x1 <<  8)	/* Source Replay Mod */
+#define	ATC_SRC_H2SEL		(0x1 <<  9)	/* Source Handshaking Mod */
+#define		ATC_SRC_H2SEL_SW	(0x0 <<  9)
+#define		ATC_SRC_H2SEL_HW	(0x1 <<  9)
+#define	ATC_SRC_PER_MSB(h)	(ATC_PER_MSB(h) << 10)	/* Channel src rq (most significant bits) */
+#define	ATC_DST_REP		(0x1 << 12)	/* Destination Replay Mod */
+#define	ATC_DST_H2SEL		(0x1 << 13)	/* Destination Handshaking Mod */
+#define		ATC_DST_H2SEL_SW	(0x0 << 13)
+#define		ATC_DST_H2SEL_HW	(0x1 << 13)
+#define	ATC_DST_PER_MSB(h)	(ATC_PER_MSB(h) << 14)	/* Channel dst rq (most significant bits) */
+#define	ATC_SOD			(0x1 << 16)	/* Stop On Done */
+#define	ATC_LOCK_IF		(0x1 << 20)	/* Interface Lock */
+#define	ATC_LOCK_B		(0x1 << 21)	/* AHB Bus Lock */
+#define	ATC_LOCK_IF_L		(0x1 << 22)	/* Master Interface Arbiter Lock */
+#define		ATC_LOCK_IF_L_CHUNK	(0x0 << 22)
+#define		ATC_LOCK_IF_L_BUFFER	(0x1 << 22)
+#define	ATC_AHB_PROT_MASK	(0x7 << 24)	/* AHB Protection */
+#define	ATC_FIFOCFG_MASK	(0x3 << 28)	/* FIFO Request Configuration */
+#define		ATC_FIFOCFG_LARGESTBURST	(0x0 << 28)
+#define		ATC_FIFOCFG_HALFFIFO		(0x1 << 28)
+#define		ATC_FIFOCFG_ENOUGHSPACE		(0x2 << 28)
+
+/* Bitfields in SPIP */
+#define	ATC_SPIP_HOLE(x)	(0xFFFFU & (x))
+#define	ATC_SPIP_BOUNDARY(x)	((0x3FF & (x)) << 16)
+
+/* Bitfields in DPIP */
+#define	ATC_DPIP_HOLE(x)	(0xFFFFU & (x))
+#define	ATC_DPIP_BOUNDARY(x)	((0x3FF & (x)) << 16)
+
+
+/*--  descriptors  -----------------------------------------------------*/
+
+/* LLI == Linked List Item; aka DMA buffer descriptor */
+struct at_lli {
+	/* values that are not changed by hardware */
+	dma_addr_t	saddr;
+	dma_addr_t	daddr;
+	/* value that may get written back: */
+	u32		ctrla;
+	/* more values that are not changed by hardware */
+	u32		ctrlb;
+	dma_addr_t	dscr;	/* chain to next lli */
+};
+
+/**
+ * struct at_desc - software descriptor
+ * @at_lli: hardware lli structure
+ * @txd: support for the async_tx api
+ * @desc_node: node on the channed descriptors list
+ * @len: descriptor byte count
+ * @total_len: total transaction byte count
+ */
+struct at_desc {
+	/* FIRST values the hardware uses */
+	struct at_lli			lli;
+
+	/* THEN values for driver housekeeping */
+	struct list_head		tx_list;
+	struct dma_async_tx_descriptor	txd;
+	struct list_head		desc_node;
+	size_t				len;
+	size_t				total_len;
+
+	/* Interleaved data */
+	size_t				boundary;
+	size_t				dst_hole;
+	size_t				src_hole;
+
+	/* Memset temporary buffer */
+	bool				memset_buffer;
+	dma_addr_t			memset_paddr;
+	int				*memset_vaddr;
+};
+
+static inline struct at_desc *
+txd_to_at_desc(struct dma_async_tx_descriptor *txd)
+{
+	return container_of(txd, struct at_desc, txd);
+}
+
+
+/*--  Channels  --------------------------------------------------------*/
+
+/**
+ * atc_status - information bits stored in channel status flag
+ *
+ * Manipulated with atomic operations.
+ */
+enum atc_status {
+	ATC_IS_ERROR = 0,
+	ATC_IS_PAUSED = 1,
+	ATC_IS_CYCLIC = 24,
+};
+
+/**
+ * struct at_dma_chan - internal representation of an Atmel HDMAC channel
+ * @chan_common: common dmaengine channel object members
+ * @device: parent device
+ * @ch_regs: memory mapped register base
+ * @mask: channel index in a mask
+ * @per_if: peripheral interface
+ * @mem_if: memory interface
+ * @status: transmit status information from irq/prep* functions
+ *                to tasklet (use atomic operations)
+ * @tasklet: bottom half to finish transaction work
+ * @save_cfg: configuration register that is saved on suspend/resume cycle
+ * @save_dscr: for cyclic operations, preserve next descriptor address in
+ *             the cyclic list on suspend/resume cycle
+ * @dma_sconfig: configuration for slave transfers, passed via
+ * .device_config
+ * @lock: serializes enqueue/dequeue operations to descriptors lists
+ * @active_list: list of descriptors dmaengine is being running on
+ * @queue: list of descriptors ready to be submitted to engine
+ * @free_list: list of descriptors usable by the channel
+ */
+struct at_dma_chan {
+	struct dma_chan		chan_common;
+	struct at_dma		*device;
+	void __iomem		*ch_regs;
+	u8			mask;
+	u8			per_if;
+	u8			mem_if;
+	unsigned long		status;
+	struct tasklet_struct	tasklet;
+	u32			save_cfg;
+	u32			save_dscr;
+	struct dma_slave_config dma_sconfig;
+
+	spinlock_t		lock;
+
+	/* these other elements are all protected by lock */
+	struct list_head	active_list;
+	struct list_head	queue;
+	struct list_head	free_list;
+};
+
+#define	channel_readl(atchan, name) \
+	__raw_readl((atchan)->ch_regs + ATC_##name##_OFFSET)
+
+#define	channel_writel(atchan, name, val) \
+	__raw_writel((val), (atchan)->ch_regs + ATC_##name##_OFFSET)
+
+static inline struct at_dma_chan *to_at_dma_chan(struct dma_chan *dchan)
+{
+	return container_of(dchan, struct at_dma_chan, chan_common);
+}
+
+/*
+ * Fix sconfig's burst size according to at_hdmac. We need to convert them as:
+ * 1 -> 0, 4 -> 1, 8 -> 2, 16 -> 3, 32 -> 4, 64 -> 5, 128 -> 6, 256 -> 7.
+ *
+ * This can be done by finding most significant bit set.
+ */
+static inline void convert_burst(u32 *maxburst)
+{
+	if (*maxburst > 1)
+		*maxburst = fls(*maxburst) - 2;
+	else
+		*maxburst = 0;
+}
+
+/*
+ * Fix sconfig's bus width according to at_hdmac.
+ * 1 byte -> 0, 2 bytes -> 1, 4 bytes -> 2.
+ */
+static inline u8 convert_buswidth(enum dma_slave_buswidth addr_width)
+{
+	switch (addr_width) {
+	case DMA_SLAVE_BUSWIDTH_2_BYTES:
+		return 1;
+	case DMA_SLAVE_BUSWIDTH_4_BYTES:
+		return 2;
+	default:
+		/* For 1 byte width or fallback */
+		return 0;
+	}
+}
+
+/*--  Controller  ------------------------------------------------------*/
+
+/**
+ * struct at_dma - internal representation of an Atmel HDMA Controller
+ * @chan_common: common dmaengine dma_device object members
+ * @atdma_devtype: identifier of DMA controller compatibility
+ * @ch_regs: memory mapped register base
+ * @clk: dma controller clock
+ * @save_imr: interrupt mask register that is saved on suspend/resume cycle
+ * @all_chan_mask: all channels availlable in a mask
+ * @dma_desc_pool: base of DMA descriptor region (DMA address)
+ * @chan: channels table to store at_dma_chan structures
+ */
+struct at_dma {
+	struct dma_device	dma_common;
+	void __iomem		*regs;
+	struct clk		*clk;
+	u32			save_imr;
+
+	u8			all_chan_mask;
+
+	struct dma_pool		*dma_desc_pool;
+	struct dma_pool		*memset_pool;
+	/* AT THE END channels table */
+	struct at_dma_chan	chan[];
+};
+
+#define	dma_readl(atdma, name) \
+	__raw_readl((atdma)->regs + AT_DMA_##name)
+#define	dma_writel(atdma, name, val) \
+	__raw_writel((val), (atdma)->regs + AT_DMA_##name)
+
+static inline struct at_dma *to_at_dma(struct dma_device *ddev)
+{
+	return container_of(ddev, struct at_dma, dma_common);
+}
+
+
+/*--  Helper functions  ------------------------------------------------*/
+
+static struct device *chan2dev(struct dma_chan *chan)
+{
+	return &chan->dev->device;
+}
+
+#if defined(VERBOSE_DEBUG)
+static void vdbg_dump_regs(struct at_dma_chan *atchan)
+{
+	struct at_dma	*atdma = to_at_dma(atchan->chan_common.device);
+
+	dev_err(chan2dev(&atchan->chan_common),
+		"  channel %d : imr = 0x%x, chsr = 0x%x\n",
+		atchan->chan_common.chan_id,
+		dma_readl(atdma, EBCIMR),
+		dma_readl(atdma, CHSR));
+
+	dev_err(chan2dev(&atchan->chan_common),
+		"  channel: s0x%x d0x%x ctrl0x%x:0x%x cfg0x%x l0x%x\n",
+		channel_readl(atchan, SADDR),
+		channel_readl(atchan, DADDR),
+		channel_readl(atchan, CTRLA),
+		channel_readl(atchan, CTRLB),
+		channel_readl(atchan, CFG),
+		channel_readl(atchan, DSCR));
+}
+#else
+static void vdbg_dump_regs(struct at_dma_chan *atchan) {}
+#endif
+
+static void atc_dump_lli(struct at_dma_chan *atchan, struct at_lli *lli)
+{
+	dev_crit(chan2dev(&atchan->chan_common),
+		 "desc: s%pad d%pad ctrl0x%x:0x%x l%pad\n",
+		 &lli->saddr, &lli->daddr,
+		 lli->ctrla, lli->ctrlb, &lli->dscr);
+}
+
+
+static void atc_setup_irq(struct at_dma *atdma, int chan_id, int on)
+{
+	u32 ebci;
+
+	/* enable interrupts on buffer transfer completion & error */
+	ebci =    AT_DMA_BTC(chan_id)
+		| AT_DMA_ERR(chan_id);
+	if (on)
+		dma_writel(atdma, EBCIER, ebci);
+	else
+		dma_writel(atdma, EBCIDR, ebci);
+}
+
+static void atc_enable_chan_irq(struct at_dma *atdma, int chan_id)
+{
+	atc_setup_irq(atdma, chan_id, 1);
+}
+
+static void atc_disable_chan_irq(struct at_dma *atdma, int chan_id)
+{
+	atc_setup_irq(atdma, chan_id, 0);
+}
+
+
+/**
+ * atc_chan_is_enabled - test if given channel is enabled
+ * @atchan: channel we want to test status
+ */
+static inline int atc_chan_is_enabled(struct at_dma_chan *atchan)
+{
+	struct at_dma	*atdma = to_at_dma(atchan->chan_common.device);
+
+	return !!(dma_readl(atdma, CHSR) & atchan->mask);
+}
+
+/**
+ * atc_chan_is_paused - test channel pause/resume status
+ * @atchan: channel we want to test status
+ */
+static inline int atc_chan_is_paused(struct at_dma_chan *atchan)
+{
+	return test_bit(ATC_IS_PAUSED, &atchan->status);
+}
+
+/**
+ * atc_chan_is_cyclic - test if given channel has cyclic property set
+ * @atchan: channel we want to test status
+ */
+static inline int atc_chan_is_cyclic(struct at_dma_chan *atchan)
+{
+	return test_bit(ATC_IS_CYCLIC, &atchan->status);
+}
+
+/**
+ * set_desc_eol - set end-of-link to descriptor so it will end transfer
+ * @desc: descriptor, signle or at the end of a chain, to end chain on
+ */
+static void set_desc_eol(struct at_desc *desc)
+{
+	u32 ctrlb = desc->lli.ctrlb;
+
+	ctrlb &= ~ATC_IEN;
+	ctrlb |= ATC_SRC_DSCR_DIS | ATC_DST_DSCR_DIS;
+
+	desc->lli.ctrlb = ctrlb;
+	desc->lli.dscr = 0;
+}
+
+#endif /* AT_HDMAC_REGS_H */
